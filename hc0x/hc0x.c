/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> HC05
* Version           -> 1.0.0.1204
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 04.12.2017 11:11:37
* Description       -> Description
*
*
*
*/
#ifndef F_CPU
#define F_CPU	16e6
#endif


#include <avr/io.h>
#include <util/delay.h>

#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>


#include "hc0x.h"
#include "cmd.h"
#include "uart_test.h"

/*
*	command table for the bluetooth µc
*   attention, for some one at commands you need the '=' or ':' character
*/

#ifdef HC05
const char *hc05Cmd[] =
{
	"AT"			, //[0] test uart connection
	"AT+RESET"		, //[1] reset device
	"AT+VERSION?"	, //[2] query firmware version
	"AT+ORGL"		, //[3] restore settings to factory defaults
	"AT+ADDR?"		, //[4] query device bluetooth address
	"AT+NAME="		, //[5] query/set device name
	"AT+RNAME?"		, //[6] query remote bluetooth device´s name
	"AT+ROLE="		, //[7] query/set device role
	"AT+ROLE?"		, //[8] set/inquire module role
	"AT+CLASS="		, //[9] query/set class of device CoD
	"AT+CLASS?"		, //[10] set / inquire device type
	"AT+IAC="		, //[11] query/set inquire access code
	"AT+IAC?"		, //[12] set/inquire access code
	"AT+INQM="		, //[13] query/set inquire access mode
	"AT+INQM?"		, //[14] set/inquire - inquire access mode
	"AT+PSWD="		, //[15] query/set pairing passkey
	"AT+PSWD?"		, //[16] set/inquire passkey
	"AT+UART="		, //[17] query/set uart parameter
	"AT+UART?"		, //[18] inquire serial parameter
	"AT+CMODE="		, //[19] set/inquire communication mode
	"AT+CMODE?"		, //[20] set/inquire connection mode
	"AT+BIND="		, //[21] set/inquire binding bluetooth address
	"AT+BIND?"		, //[22] setü/inquire binding bluetooth address
	"AT+POLAR="		, //[23] query/set led output polarity
	"AT+PIO="		, //[24] set/reset a user i/o pin
	"AT+MPIO="		, //[25] set/reset multiple user i/0 pin
	"AT+MPIO?"		, //[26] query user i/o pin
	"AT+IPSCAN="	, //[27] set/inquire scanning parameters
	"AT+IPSCAN?"	, //[28] set/inquire scanning parameters
	"AT+SNIFF="		, //[29] set/inquire sniff energy savings parameters
	"AT+SENM="		, //[30] set/inquire security & encryption modes
	"AT+SENM?"		, //[31] set/inquire security & encryption modes
	"AT+PMSAD="		, //[32] delete authenticated device from list
	"AT+RMAAD"		, //[33] delete all authenticated devices in thne pair list
	"AT+FSAD="		, //[34] seek the authenticated device in the bluetooth pair list
	"AT+ADCN?"		, //[35] get the authenticated device count from the pair list
	"AT+MRAD?"		, //[36] query most recently used authenticated device
	"AT+STATE?"		, //[37] query current state of the device
	"AT+INIT"		, //[38] initialize spp profile
	"AT+INQ"		, //[39] query nearby discoverable devices
	"AT+INQC"		, //[40] cancel search for discoverable devices
	"AT+PAIR="		, //[41] device pairing
	"AT+LINK="		, //[42] connect to a remote device
	"AT+DISC"		, //[43] disconnect from a remote device
	"AT+ENSNIFF="	, //[44] enter energy saving mode
	"AT+EXSNIFF="	, //[45] exit energy saving mode
};
#elif defined HC06
const char *hc06Cmd[] =
{
	"AT",
	"AT+BAUD1", //1200
	"AT+BAUD2", //2400
	"AT+BAUD3", //4800
	"AT+BAUD4", //9600
	"AT+BAUD5", //19200
	"AT+BAUD6", //38400
	"AT+BAUD7", //57600
	"AT+BAUD8", //115200
	"AT+NAME",
	"AT+PIN",
	"AT+PN",
};
#endif

hc0x_t blth;

static uint8_t crc8_(char *inData)
{
	uint8_t   i = 0x00;
	uint8_t   data = 0x00;
	
	while(*inData)
	{
	    data = data ^ *inData++;

	    for ( i = 0; i < 8; i++ )
	    {
		    if (( data & 0x80 ) != 0 )
		    {
			    data <<= 1;
			    data ^= 0x07;
		    }
		    else
		    {
			    data <<= 1;
		    }
	    }		
	}
	return data;
}

#ifdef HC05
static char *checkMAC(char *mac)
{
	uint8_t leng = 0x00;
	uint8_t delimiter = 0x00;

	while(*mac!='\0')
	{
		if(*mac==',')*mac='\0';
		if(*mac==':')delimiter++;	
		mac++;leng++;		
	}mac-=leng;
	
	/*
	*	wrong mac format
	*/
	if(delimiter != 2)return NULL;	

	delimiter 	= 0x00;
	leng 		= 0x00;
	
	while(*mac!=':')
	{
		delimiter++;mac++;leng++;
	}mac-=leng;

	/*
	*	xxxx,XX,XXXX
	*	a mac address block must have 4 chars
	*/
	delimiter = 4-delimiter;
	
	char *tmp=malloc(sizeof(char)*14);
	
	if(delimiter == 1)
	strcpy(tmp,"0");	
	else if(delimiter == 2)
	strcpy(tmp,"00");
			
	strcat(tmp,mac);
	
	while(*tmp != '\0')
	{
		if(*tmp == ':')*tmp = ',';
		tmp++;
	}tmp-=14;
	
	strcpy(mac,tmp);
	
	return mac;
}
#endif 

bool readRingBuff(char *buff)
{
	static uint8_t index = 0;
	
	/*
	*	read byte from buffer
	*/
	uint16_t c = uart1_getc();
	
	/*
	*	if data available?
	*/
	if ( c & UART_NO_DATA)
	{
		return false;
	}
	
	/*
	*	if any uart error?
	*/
	if ( c > UART_NO_DATA)
	{
		index = 0; 
		return false;
	}
	
	/*
	*	mask out all errors & states
	*/
	c &= 0x00FF;
	
	/*
	*	end of transmission?
	*/
	if (c == '#' || c == '\n' || c == '\r')
	{
		buff[index] = '\0';
			 
		index = 0; 
		blth.crc = crc8_(buff);
		return true;
	}
	
	/*
	*	save data to buffer
	*/
	if (index >= UART_RX1_BUFFER_SIZE)
	index = 0;
	else
	buff[index++] = (uint8_t)c;
	
	return false;
}

void cmdToBuff(char *buff, hc0x_t *blth)
{
	uint8_t charCnt = 0x00;
	
	while(*buff != '\0')
	{
		if(blth->dataInBuff > sizeof(blth->tx) / sizeof(blth->tx[0])) // check buffer overflow
		blth->dataInBuff = 0;
		
		blth->tx[blth->dataInBuff][charCnt++] = *buff++;
	}
	blth->dataInBuff++;
}

void buildCmd(const char *cmd, char *para)
{
	char buff[30]="";
	
	if(cmd != NULL)
	strcpy(buff,cmd);
	if(para != NULL)
	strcat(buff,para);
	
	#ifdef HC05
	strcat(buff,HC05_EOC);
	#endif
	
	cmdToBuff(buff,&blth);
}

void txBuffer(hc0x_t *buff)
{
	uint8_t index = 0;
	
	while(index < buff->dataInBuff)
	{
		uart1_puts(buff->tx[index++]);
		_delay_ms(COMMAND_TRANSMIT_DELAY);
	}
}

void clearTxBuff(hc0x_t *blth)
{	
	while(blth->dataInBuff > 0)
	{
		uint8_t tmp = 0;
		
		for(tmp = 0 ; tmp < sizeof(blth->tx[blth->dataInBuff]) ; tmp++)
		{
			blth->tx[blth->dataInBuff][tmp] = 0;
		}
		blth->dataInBuff--;
	}
	blth->dataInBuff = 0;
}

#ifdef HC05
char *waitForOk(char *inBuff)
{	
	memset(inBuff,0,strlen(inBuff));
	
	while(1)
	{
		txBuffer(&blth);
		if(readRingBuff(inBuff)==true)
		{
			if (cmd.Search(inBuff,"OK")==0)
			{
				strcpy(inBuff,"OK");
				break;
			}
			if (cmd.Search(inBuff,"ERROR")==0)
			{
				strcpy(inBuff,"EROOR");
				break;
			}
		}
	}clearTxBuff(&blth);memset(inBuff,0,strlen(inBuff));
	
	return NULL;
}
#elif defined HC06
char *waitForx(char *inBuff, char *waitFor)
{
	memset(inBuff,0,strlen(inBuff));

	while(1)
	{		
		txBuffer(&blth);
		_delay_ms(1000);
			
		if(readRingBuff(inBuff)==true)
		{	
			if (cmd.Search(inBuff,waitFor,0)==0)
			{
				break;
			}
		}
	}clearTxBuff(&blth);memset(inBuff,0,strlen(inBuff));
	
	return NULL;
}
#endif

#ifdef HC05
char *connect(char *addr, char *tmeOut, char *inBuff)
{
	/*
	*	build pair command ("98D3,31,804EDB,20")
	*/
	char pairCmd[17]="";
	strcpy(pairCmd,addr);
	strcat(pairCmd,tmeOut);
	
	buildCmd(hc05Cmd[1]	,NULL);	// reset
	if(waitForOk(inBuff)==0)
		strcpy(inBuff,"reset_ok,");
	else
		strcpy(inBuff,"reset_err,");
	
	buildCmd(hc05Cmd[38]	,NULL);	// at init spp profile
	if(waitForOk(inBuff)==0)
		strcpy(inBuff,"init_ok,");
	else
		strcpy(inBuff,"init_err,");
		 
	buildCmd(hc05Cmd[41],pairCmd); // at pair
	if(waitForOk(inBuff)==0)
		strcpy(inBuff,"pair_ok,");
	else
		strcpy(inBuff,"pair_err,");
		 
 	buildCmd(hc05Cmd[21],addr); // at bind
	if(waitForOk(inBuff)==0)
		strcpy(inBuff,"bind_ok,");
	else
		strcpy(inBuff,"bind_err,");
		  	
 	buildCmd(hc05Cmd[42],addr); // at link	
	if(waitForOk(inBuff)==0)
		strcpy(inBuff,"link_ok,");
	else
		strcpy(inBuff,"link_err,");
		
	return inBuff;	
}
#endif

#ifdef HC05
char *getBlthName(char *addr, char *inBuff)
{
	/*
	*	clear command buffer
	*/
	clearTxBuff(&blth);
	
	/*
	*	clear input buffer
	*/
	memset(inBuff,0,strlen(inBuff));
	
	/*
	*	fill command buffer
	*/
	buildCmd(hc05Cmd[6],addr);	      // get bluetooth name
	txBuffer(&blth);
	
	while(1)
	{
		if(readRingBuff(inBuff)==true)
		{
			if (cmd.Search(inBuff,"+RNAME:xxxxxxxxxxxxxxxxxxxxxx") == 0)
			{
				return(&inBuff[7]);
			}
			//if(cmd.Search(inBuff,"OK") == 0)break;
			if(cmd.Search(inBuff,"FAIL") == 0)break;
		}
	}
	return NULL;
}
#endif

#ifdef HC05
char *scanForDevices(char *inBuff )
{
	/*
	*	clear command buffer
	*/
	clearTxBuff(&blth);
	
	/*
	*	clear input buffer
	*/
	memset(inBuff,0,strlen(inBuff));
	
	/*
	*	fill command buffer
	*/
	buildCmd(hc05Cmd[7]		,"1");	      // at role
	buildCmd(hc05Cmd[38]	,NULL);	      // at init spp profile
	buildCmd(hc05Cmd[11]	,"9E8B33");	  // at Inquire code
	buildCmd(hc05Cmd[9]		,"0");		  // at class
	buildCmd(hc05Cmd[13]	,"0,3,10");   // Inquire access mode
	buildCmd(hc05Cmd[39]	,NULL);	      // Inquire Bluetooth device
	txBuffer(&blth);
	
	/*
	*	clear all OK messages
	*/
	for (uint8_t tmp = 0x00 ; tmp < UART_RX1_BUFFER_SIZE ; tmp++){uart1_getc();}

	/*
	*	
	*	sample mac.: 8C1A:BF:75BA33
	*/	
	while(1)
	{
		if(readRingBuff(inBuff)==true)
		{				
			if (cmd.Search(inBuff,"+INQ:xxxxxxxxxxxxxx") == 0)
			{
				inBuff+=5;
				for (uint8_t tmp = 0 ; tmp < 14 ; tmp++) // strlen of mac = 14
				{
					blth.addr[blth.addrFound][tmp] = *inBuff++;
				}
				blth.addr[blth.addrFound][14] = '\0';
				
				/*
				*	check mac for right format!
				*/
				checkMAC(blth.addr[blth.addrFound]);
				
				/*
				*	new bluetooth device found
				*/
				blth.addrFound++;
			}
			if (cmd.Search(inBuff,"OK") == 0)break;
		}
	}	
	if (blth.addrFound>0)
	{
		return blth.addr[0]; // return first address of bluetooth device
	}else
	return NULL;
}
#endif 

#ifdef HC05
char *getState(char *inBuff)
{	
	/*
	*	clear command buffer
	*/
	clearTxBuff(&blth);
	
	/*
	*	clear input buffer
	*/
	memset(inBuff,0,strlen(inBuff));
	
	/*
	*	fill command buffer
	*/
	buildCmd(hc05Cmd[37],NULL); // get state
	txBuffer(&blth);
	
	while(1)
	{
 		if(readRingBuff(inBuff)==true)
 		{		
			txBuffer(&blth);
 			if(cmd.Search(inBuff,"+STATE:xxxxxxxxxxxx") == 0)
 			{
				if(cmd.Search(&inBuff[7],"READY")			  == 0)return &inBuff[7];
				else if(cmd.Search(&inBuff[7],"PAIRABLE")     == 0)return &inBuff[7];
				else if(cmd.Search(&inBuff[7],"PAIRED")       == 0)return &inBuff[7];
				else if(cmd.Search(&inBuff[7],"INQUIRING")    == 0)return &inBuff[7];
				else if(cmd.Search(&inBuff[7],"CONNECTING")   == 0)return &inBuff[7];
				else if(cmd.Search(&inBuff[7],"CONNECTED")    == 0)return &inBuff[7];
				else if(cmd.Search(&inBuff[7],"DISCONNECTED") == 0)return &inBuff[7];
				else if(cmd.Search(&inBuff[7],"INITIALIZED")  == 0)return &inBuff[7];
 			}		 
 		}
	}
	return NULL;
}
#endif

#ifdef HC05
hc05_fnc hc05 =
{
	.waitForOk			= waitForOk,
	.connect			= connect,
	.getBlthName		= getBlthName,
	.scanForDevices		= scanForDevices,
	.getState			= getState,
	.cmdToBuff			= cmdToBuff,
	.buildCmd			= buildCmd,
	.txBuffer			= txBuffer,
	.clearTxBuff		= clearTxBuff,
};
#elif defined HC06
hc06_fnc hc06 =
{
	.waitForx			= waitForx,
	.cmdToBuff			= cmdToBuff,
	.buildCmd			= buildCmd,
	.txBuffer			= txBuffer,
	.clearTxBuff		= clearTxBuff,
};
#endif 