/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> STPM32
* Version           -> 1.0.0.0621
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 21.06.2018 07:49:56
* Description       -> Description
*
*
*
*/

#include "../Headers/wsq3000_def.h"

#include <avr/io.h>
#include <stdlib.h>
#include <string.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include "../Headers/stpm32.h"


/*
*	Datenstruktur
*/
stpm32_t stpm32;





static void				stpm32Select	( void )
{
	__STPM32_PIN_LOW__( STPM32_SCS_PORT , STPM32_SCS_bp );
}

static void				stpm32Deselect	( void )
{
	__STPM32_PIN_HIGH__( STPM32_SCS_PORT , STPM32_SCS_bp );
}



static  inline uint8_t	stpm32CalcCRC	( uint8_t inCrc , uint8_t inData )
{
	uint8_t   i;
	uint8_t   data;

	data = inCrc ^ inData;

	for ( i = 0; i < 8; i++ )
	{
		if ( data & 0x80 )
		{
			data <<= 1;
			data ^= 0x07;
		}
		else
		{
			data <<= 1;
		}
	}
	return data;
}

static inline void		stpm32SpiWrite	( uint8_t *buff , size_t leng )
{
	uint8_t x;
	
	stpm32Select();
	for ( x = 0 ; x < leng ; x++ )
	{
		spiMasterWriteRead( buff[x] );
	}

	for ( x = 0 ; x < leng ; x++ )
	{
		spiMasterWriteRead( 0xFF );
	}
	stpm32Deselect();
}

static inline void		stpm32SpiRead	( uint8_t *buff )
{	
	uint8_t frame[5] = { buff[0] , 0xFF , 0xFF , 0xFF , 0x00 }; // buff[0] = Register Adresse
		
	__STPM32_PIN_LOW__( STPM32_SYNC_PORT , STPM32_SYNC_bp );
  	_delay_ms(10);
  	__STPM32_PIN_HIGH__( STPM32_SYNC_PORT , STPM32_SYNC_bp );
  	_delay_ms(10);		
	
	stpm32Select();
	for ( uint8_t i = 0 ; i < ( STPM32_FRAME_WITHOUT_CRC + STPM32_CRC_MODE ) ; i++ )
	{
		spiMasterWriteRead( frame[i] );
	}		

	for ( uint8_t i = 0 ; i < ( STPM32_FRAME_WITHOUT_CRC + STPM32_CRC_MODE ) ; i++ )
	{
		*buff++ = spiMasterWriteRead( 0xFF );
	}
	stpm32Deselect();
}

static inline void		stpm32Reset		( void )
{
	for ( uint8_t x = 0 ; x < 3 ; x++ )
	{
		__STPM32_PIN_LOW__( STPM32_SYNC_PORT , STPM32_SYNC_bp );
		_delay_ms( 10 );
		__STPM32_PIN_HIGH__( STPM32_SYNC_PORT , STPM32_SYNC_bp );
		_delay_ms( 10 );
	}
	
	__STPM32_PIN_LOW__( STPM32_SYNC_PORT , STPM32_SYNC_bp );
	
	spiMasterWrite( 0x00 );
	
	_delay_ms( 100 );
	
	__STPM32_PIN_HIGH__( STPM32_SYNC_PORT , STPM32_SYNC_bp );
	
}

static inline void		stpm32StartUp	( void )
{	
	__STPM32_PIN_LOW__( STPM32_EN_PORT , STPM32_EN_bp );
  	_delay_ms(50);

	__STPM32_PIN_LOW__( STPM32_SCS_PORT , STPM32_SCS_bp );
  	_delay_ms(50);

	__STPM32_PIN_HIGH__( STPM32_EN_PORT , STPM32_EN_bp );
}

static void				stpm32Write		( uint8_t addr , uint16_t cmd )
{		
	/*
	*	Kommando Byte bauen und mit Daten versehen
	*/
	uint8_t buff[STPM32_COM_PROTOCOL] = 
	{
		0xFF						, // STPM32_READ_ADDR
		addr						, // STPM32_WRITE_ADDR
		( cmd & 0x00FF )       		, // STPM32_CMD_LSB
		( ( cmd & 0xFF00 ) >> 8 ) 	, // STPM32_CMD_MSB
		0							, // STPM32_CRC
	};
	
	for ( uint8_t x = 0 ; x < STPM32_FRAME_WITHOUT_CRC ; x++ )
	{
		buff[STPM32_CRC] = stpm32CalcCRC( buff[STPM32_CRC] , *(buff + x) );
	}
	
	stpm32SpiWrite( buff , STPM32_FRAME_WITHOUT_CRC + STPM32_CRC_MODE ); 

}

static void				stpm32Write_	( uint8_t addr , uint32_t cmd )
{
	uint8_t frameLow	[]	= { 0xFF , addr		, ( cmd & 0x000000FF ) , ( ( cmd & 0x0000FF00) >> 8 ) , 0x00 };
	uint8_t frameHigh	[]	= { 0xFF , addr + 1 , ( ( cmd & 0x00FF0000 ) >> 16 ) , ( ( cmd & 0xFF000000) >> 24 ) , 0x00 };
	
	for ( uint8_t x = 0 ; x < STPM32_FRAME_WITHOUT_CRC ; x++ )
	{
		frameLow[STPM32_CRC] = stpm32CalcCRC( frameLow[STPM32_CRC] , frameLow[x] );
	}
	stpm32SpiWrite( frameLow , ( STPM32_FRAME_WITHOUT_CRC + STPM32_CRC_MODE ) );
	
	for ( uint8_t x = 0 ; x < STPM32_FRAME_WITHOUT_CRC ; x++ )
	{
		frameHigh[STPM32_CRC] = stpm32CalcCRC( frameHigh[STPM32_CRC] , frameHigh[x] );
	}
	stpm32SpiWrite( frameHigh , ( STPM32_FRAME_WITHOUT_CRC + STPM32_CRC_MODE ) );
}

static int8_t			stpm32Read		( uint8_t addr , uint8_t *buff )
{
	uint8_t crcRX = 0;
	int8_t	ret = 0;
	
	*buff = addr;
	stpm32SpiRead( buff );
	
	for ( uint8_t x = 0 ; x < ( STPM32_FRAME_LENG - 1 ) ; x++ )
	{
		crcRX = stpm32CalcCRC( crcRX , buff[x] );
	}	
	
	stpm32.crc.lastRx = buff[STPM32_FRAME_LENG - 1]; // Empfangene CRC sichern

	if ( STPM32_CRC_MODE == 1 )
	{
		if ( stpm32.crc.lastRx != crcRX )
		{
			stpm32.crc.cnt++; // Wie oft ein CRC Fehler aufgetreten ist
			return -1;
		}
	}

	return ret;
}

static uint16_t			stpm32CalcVrms	( uint32_t ad )
{
	return ( ad & 0x7FFF ) * STPM32_VLSB;
}

static float			stpm32CalcIrms	( uint32_t ad )
{
	return ( ( ad & 0xFFFF8000 ) >> 15 ) * STPM32_ILSB;
}

static uint32_t			stpm32CalcXv	( uint16_t volt )
{
	return ( ( volt / STPM32_VLSB * 1000 ) );
}

static uint32_t			stpm32CalcXi	( uint16_t data	)
{
	return ( data / STPM32_ILSB );
}



void		stpm32Init			( void )
{
	__STPM32_PIN_OUTPUT__( STPM32_SYNC_PORT , STPM32_SYNC_bp );
	__STPM32_PIN_OUTPUT__( STPM32_SCS_PORT , STPM32_SCS_bp );
	__STPM32_PIN_OUTPUT__( STPM32_EN_PORT , STPM32_EN_bp );
	
	stpm32StartUp();
	
	stpm32Reset();
	
	uint8_t buff[5] = "";
	stpm32Read( DSP_REG3 , buff );
	uint32_t tmp = BUILD_UINT32( buff );
	tmp &= ~(1UL<<27);
	stpm32Write_( DSP_REG3 , tmp);
	
	#if STPM32_CRC_MODE == 1
		stpm32CrcEnable();
	#else 
		stpm32CrcDisable();
	#endif
}

void		stpm32CrcEnable		( void )
{
	/*
	*	Siehe Datenblatt Seite.: 69
	*/
	uint8_t buff[] =
	{
		0x24,
		0x24,
		0x07,
		0x40,
		0xD2, // CRC
	};
	
	stpm32SpiWrite( buff , STPM32_COM_PROTOCOL ); // Kommando wird mit CRC gesendet
}
	
void		stpm32CrcDisable	( void )
{
	/*
	*	Siehe Datenblatt Seite.: 69
	*/
	uint8_t buff[] =
	{
		0x24,
		0x24,
		0x07,
		0x00,
		0x15, // CRC
	};
	
	stpm32SpiWrite( buff , STPM32_COM_PROTOCOL ); 
}

void		stpm32CrcSetPoly	( uint8_t poly )
{
	/*
	*	Siehe Datenblatt Seite.: 69
	*/	
	stpm32Write( 0x24 , poly ); 	
}

uint8_t		stpm32Online		( void )
{
	uint8_t buff[5];
	stpm32Write_( 0x1E , 0b11111111000000001111111100000000 );
	stpm32Read	( 0x1E , buff );
	
	stpm32Write_( 0x1E , 0 );
	
	if ( BUILD_UINT32( buff ) == 0b11111111000000001111111100000000 )
	{
		return 0; // Online
	}
	
	return 1; // Offline
}

uint32_t	stpm32GetVoltageAD	( void )
{
	uint8_t buff[5] = "";
	
	stpm32Read( 0x48 , buff );
	
	return ( BUILD_UINT32( buff ) & 0x7FFF );
}

uint32_t	stpm32GetCurrentAD	( void )
{
	uint8_t buff[5] = "";
	
	stpm32Read( 0x48 , buff );
	
	return ( ( BUILD_UINT32( buff ) & 0xFFFF8000 ) >> 15 );	
}

uint32_t	stpm32CalcCHV		( uint16_t vCal , uint32_t vADRead )
{
	return ( ( 14336 *  stpm32CalcXv( vCal ) / ( vADRead & 0x7FFF ) - 12288 ) );
}

void		stpm32SetCHV		( uint16_t val )
{
	stpm32Write_( DSP_CR5 , val );
}

uint32_t	stpm32CalcCHC		( uint8_t iCal , uint32_t iADRead )
{
	return ( ( 14336 *  stpm32CalcXi( iCal ) /  ( iADRead ) - 12288 ) ) ;
}

void		stpm32SetCHC		( uint16_t val )
{
	stpm32Write_( DSP_CR6 , val );
}

uint16_t	stpm32GetVoltage	( void )
{
	uint8_t buff[5] = "";
	stpm32Read( 0x48 , buff );
	
	return ( stpm32CalcVrms( BUILD_UINT32( buff ) ) );
}

float		stpm32GetCurrent	( void )
{
	uint8_t buff[5] = "";
	stpm32Read( 0x48 , buff );
	
	return ( stpm32CalcIrms( BUILD_UINT32( buff ) ) );
}

void		stpm32GetPeriod		( stpm32_t *s )
{
	uint8_t buff[5] = "";
	
	stpm32Read( DSP_REG3 , buff );
	uint32_t tmp = BUILD_UINT32( buff );
	tmp &= ~(1UL<<27);
	stpm32Write_( DSP_REG3 , tmp);
	
	stpm32Read( DSP_REG1 , buff );
	
	s->ch1.period = (float)( ( buff[1] << 8 | buff[0] ) & 0xFFF );
	s->ch2.period = (float)( ( buff[3] << 8 | buff[2] ) & 0xFFF );
}

void		stpm32GetPhaseAngel ( stpm32_t *s )
{
	stpm32GetPeriod( s );
	
	uint8_t buff[5] = "";
	
	stpm32Read( DSP_REG17 , buff );
	
	uint16_t angel = ( ( ( uint16_t ) buff[3] << 8) | buff[2] ) & 0x00000FFF;
	
	s->ch1.phaseAngel = ( ( angel * STPM32_CALC_FREQUENCY( s->ch1.period ) ) * 360 ) / 125000;
}

void		stpm32GetApparentRMSPower	( stpm32_t *s )
{
	uint8_t buff[5] = "";
	stpm32Read( PH1_REG8 , buff );

	uint32_t tmp = BUILD_UINT32( buff );
	
	if ( tmp & 0x10000000 ) // Vorzeichen prüfen ( Zweierkomplement ) 
	{
		s->ch1.apparentRmsPower = ((float)(((tmp ^ 0xFFFFFFF) & 0xFFFFFFF) + 1) * STPM32_POWER_LSB)*-1; // Berechnung in Milliwatt[mW]
	}
	else
	{
		s->ch1.apparentRmsPower = ((float)(tmp & 0xFFFFFFF)) * STPM32_POWER_LSB; // Berechnung in Milliwatt[mW]
	}
}

void		stpm32GetApparentEnergy		( stpm32_t *s )
{
	uint8_t buff[5] = "";
	stpm32Read( PH1_REG4 , buff );
	
	s->ch1.apparentEnergy = (float)BUILD_UINT32( buff ) * STPM32_ENERGY_LSB; // mWs
	
	/* Wattstunde(n)
	* s->ch1.apparentEnergy *= 0,000277778; // Wh ( Watt Stunde(n) )
	*/
}

uint8_t stpm32ErrorState = 0;

/* UNGETESTET! */
stpm32_error_enum_t		stpm32StartCalibration	( uint16_t *chv , uint16_t *chc )			
{	
	uint32_t	adRmsVoltage		= 0x00000000,
				adVoltage			= 0x00000000,
				adRmsCurrent		= 0x00000000,
				adCurrent			= 0x00000000,	
				rmsVoltageMin		= 0xFFFFFFFF,
				rmsVoltageMinOld	= 0xFFFFFFFF,
				rmsVoltageMax		= 0x00000000,
				rmsVoltageMaxOld	= 0x00000000,
				rmsCurrentMin		= 0xFFFFFFFF,
				rmsCurrentMinOld	= 0xFFFFFFFF,
				rmsCurrentMax		= 0x00000000,
				rmsCurrentMaxOld	= 0x00000000;
	
	uint8_t		x;
	
	stpm32SetCHV( 2048 ); // Register auf default setzen..
	stpm32SetCHC( 2048 ); // ..
	

	for( x = 0 ; x < 100 ; x++ )
	{		
		adVoltage = stpm32GetVoltageAD();
		adCurrent = stpm32GetCurrentAD();

		adRmsVoltage += adVoltage;
		adRmsCurrent += adCurrent;
		
		/*
		*	Spannungs Schwellen
		*/
		rmsVoltageMin = adVoltage;
		if ( rmsVoltageMin < rmsVoltageMinOld )
		{
			rmsVoltageMinOld = rmsVoltageMin;
		}
			
		rmsVoltageMax = adVoltage;
		if ( rmsVoltageMax > rmsVoltageMaxOld )
		{
			rmsVoltageMaxOld = rmsVoltageMax;
		}
		
		/*
		*	Strom Schwellen
		*/
		rmsCurrentMin = adCurrent;
		if ( rmsCurrentMin < rmsCurrentMinOld )
		{
			rmsCurrentMinOld = rmsCurrentMin;
		}
		
		rmsCurrentMax = adCurrent;
		if ( rmsCurrentMax > rmsCurrentMaxOld )
		{
			rmsCurrentMaxOld = rmsCurrentMax;
		}
		
	}
		
	adRmsVoltage /= x;
	adRmsCurrent /= x;

	uint16_t rmsVoltageSpan = rmsVoltageMaxOld - rmsVoltageMinOld; // Differenz zwischen dem höchst bzw. niedrigst gemessenen Wert
	uint16_t rmsCurrentSpan = rmsCurrentMaxOld - rmsCurrentMinOld; // Differenz zwischen dem höchst bzw. niedrigst gemessenen Wert
	
	*chv = stpm32CalcCHV( STPM32_CAL_VOLTAGE , adRmsVoltage  ) / 100;
	*chc = stpm32CalcCHC( STPM32_CAL_VOLTAGE , adRmsCurrent  ) / 100;
	
	if ( ( *chv > 1600 ) && ( *chv < 1900 ) && ( rmsVoltageSpan < 300 ) )
	{
		stpm32SetCHV( *chv );
	}
	else
	{
		stpm32ErrorState |= 1<<STPM32_ERROR_CHV_FAIL;		
	}

	if ( ( *chc > 1000 ) && ( *chc  < 1050 ) && ( rmsCurrentSpan < 20 ) )
	{	
		stpm32SetCHC( *chc );
	}
	else
	{
		stpm32ErrorState |= 1<<STPM32_ERROR_CHC_FAIL;
	}
		
	
	return stpm32ErrorState;
}