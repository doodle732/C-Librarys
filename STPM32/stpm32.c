/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> STPM32
* Version           -> 1.0.0.0621
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 21.06.2018 07:49:56
* Description       -> Description
*
*
*
*/

#include "../Headers/wsq3000_def.h"

#include <avr/io.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <util/delay.h>
#include "stpm32.h"


/*
*	Datenstruktur
*/
stpm32_t stpm32;


static uint8_t stpm32Crc ( uint8_t inCrc , uint8_t inData )			
{
	uint8_t   i;
	uint8_t   data;

	data = inCrc ^ inData;

	for ( i = 0; i < 8; i++ )
	{
		if ( data & 0x80 )
		{
			data <<= 1;
			data ^= 0x07;
		}
		else
		{
			data <<= 1;
		}
	}
	return data;
}

static void stpm32SpiWrite( uint8_t *buff , size_t leng )			
{
	uint8_t x;
		
	STPM32_SYNC_PORT.OUTCLR = ( 1 << STPM32_SYNC_bp );
	_delay_ms(50);
	STPM32_SYNC_PORT.OUTSET = ( 1 << STPM32_SYNC_bp );
	_delay_ms(50);
	
	stpm32Select();
	for ( x = 0 ; x < leng ; x++ )
	{
		stpm32.spiTxRx( buff[x] );
	}
	stpm32Deselect();
	
	stpm32Select();
	for ( x = 0 ; x < leng ; x++ )
	{
		stpm32.spiTxRx( 0xFF );
	}
	stpm32Deselect();
}

static void stpm32SpiRead( uint8_t *buff , bool crcEn )				
{	
	uint8_t reg = buff[0];
	uint8_t frame[] = { reg , 0xFF , 0xFF , 0xFF , 0x00 };
		
	STPM32_SYNC_PORT.OUTCLR = ( 1 << STPM32_SYNC_bp );
	_delay_ms(50);
	STPM32_SYNC_PORT.OUTSET = ( 1 << STPM32_SYNC_bp );
	_delay_ms(50);
	
	stpm32Select();
	for ( uint8_t i = 0 ; i < ( STPM32_FRAME_LENG - 1 ) + crcEn ; i++ )
	{
		stpm32.spiTxRx( frame[i] );
	}		
	
	for ( uint8_t i = 0 ; i < ( STPM32_FRAME_LENG - 1 ) + crcEn ; i++ )
	{
		*buff++ = stpm32.spiTxRx( 0xFF ); // Dummy Bytes zum lesen senden
	}
	stpm32Deselect();
}


void stpm32Write( uint8_t addr , uint16_t cmd , bool crcEn )		
{		
	/*
	*	Kommando Byte bauen und mit Daten versehen
	*/
	uint8_t buff[STPM32_COM_PROTOCOL] = 
	{
		0xFF						, // STPM32_READ_ADDR
		addr						, // STPM32_WRITE_ADDR
		( cmd & 0x00FF )       		, // STPM32_CMD_LSB
		( ( cmd & 0xFF00 ) >> 8 ) 	, // STPM32_CMD_MSB
		0							, // STPM32_CRC
	};
	
	for ( uint8_t x = 0 ; x < STPM32_FRAME_WITHOUT_CRC ; x++ )
	{
		buff[STPM32_CRC] = stpm32Crc( buff[STPM32_CRC] , *(buff + x) );
	}
	
	stpm32SpiWrite( buff , ( STPM32_FRAME_WITHOUT_CRC + crcEn ) ); 

}

void stpm32Write_( uint8_t addr , uint32_t cmd , bool crcEn )		
{
	uint8_t frameLow	[]	= { 0xFF , addr		, ( cmd & 0x000000FF ) , ( ( cmd & 0x0000FF00) >> 8 ) , 0x00 };
	uint8_t frameHigh	[]	= { 0xFF , addr + 1 , ( ( cmd & 0x00FF0000 ) >> 16 ) , ( ( cmd & 0xFF000000) >> 24 ) , 0x00 };
	
	for ( uint8_t x = 0 ; x < STPM32_FRAME_WITHOUT_CRC ; x++ )
	{
		frameLow[STPM32_CRC] = stpm32Crc( frameLow[STPM32_CRC] , frameLow[x] );
	}
	stpm32SpiWrite( frameLow , ( STPM32_FRAME_WITHOUT_CRC + crcEn ) );
	
	for ( uint8_t x = 0 ; x < STPM32_FRAME_WITHOUT_CRC ; x++ )
	{
		frameHigh[STPM32_CRC] = stpm32Crc( frameHigh[STPM32_CRC] , frameHigh[x] );
	}
	stpm32SpiWrite( frameHigh , ( STPM32_FRAME_WITHOUT_CRC + crcEn ) );
}






void stpm32SpiInit		( stpm32_t *s )									
{
	STPM32_SYNC_PORT.DIRSET = ( 1 << STPM32_SYNC_bp );
	STPM32_SS_PORT.DIRSET	= ( 1 << STPM32_SS_bp	);
	STPM32_EN_PORT.DIRSET	= ( 1 << STPM32_EN_bp	);
	
	STPM32_EN_PORT.OUTCLR	= ( 1 << STPM32_EN_bp	);
	_delay_ms(50);
	
	STPM32_SS_PORT.OUTCLR	= ( 1 << STPM32_SS_bp	);
	_delay_ms(50);
	
	STPM32_EN_PORT.OUTSET	= ( 1 << STPM32_EN_bp	);
	
	
	s->spiTxRx				= STPM32_TX_RX;
}

int8_t stpm32Read		( uint8_t addr , uint8_t *buff , bool crcEn )	
{
	uint8_t crcRX = 0;
		
	*buff = addr;
	stpm32SpiRead( buff , crcEn );
	
	for ( uint8_t x = 0 ; x < ( STPM32_FRAME_LENG - 1 ) ; x++ )
	{
		crcRX = stpm32Crc( crcRX , buff[x] );
	}	
	
	stpm32.lastRxCrc = buff[4];
	stpm32.lastTxCrc = crcRX;
	
	if ( stpm32.lastRxCrc != stpm32.lastTxCrc )
	{
		stpm32.crcErr++;
		return -1; // CRC Error zurückgeben
	}
	
	return 0;
}

void stpm32CrcEnable	( bool crcEn )									
{
	/*
	*	Siehe Datenblatt Seite.: 69
	*/
	uint8_t buff[] =
	{
		0x24,
		0x24,
		0x07,
		0x40,
		0xD2, // CRC
	};
	
	stpm32SpiWrite( buff , ( STPM32_FRAME_WITHOUT_CRC + crcEn ) ); // Kommando wird mit CRC gesendet
}
	
void stpm32CrcDisable	( bool crcEn )									
{
	/*
	*	Siehe Datenblatt Seite.: 69
	*/
	uint8_t buff[] =
	{
		0x24,
		0x24,
		0x07,
		0x00,
		0x15, // CRC
	};
	
	stpm32SpiWrite( buff , ( STPM32_FRAME_WITHOUT_CRC + crcEn ) ); 
}

void stpm32CrcSetPoly	( uint8_t poly , uint8_t crcEn )				
{
	/*
	*	Siehe Datenblatt Seite.: 69
	*/	
	stpm32Write( 0x24 , poly , 1 ); 	
}

uint8_t stpm32Online	( void )
{
	uint8_t buff[5];
	stpm32Write_( 0x1E , 0b11111111000000001111111100000000  , 1 );
	stpm32Read	( 0x1E , buff , 1 );
	
	stpm32Write_( 0x1E , 0  , 1 );
	
	if ( BUILD_UINT32( buff ) == 0b11111111000000001111111100000000 )
	{
		return 0;
	}
	
	return 1;
}

void stpm32Select		( void )										
{
	STPM32_SS_PORT.OUTCLR = 1<<STPM32_SS_bp;
}

void stpm32Deselect		( void )										
{
	STPM32_SS_PORT.OUTSET = 1<<STPM32_SS_bp;
}