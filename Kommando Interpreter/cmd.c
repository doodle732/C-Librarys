/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> Kommando Interpreter
* Version           -> 1.0.1.1124
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 20.09.2017 07:50:01
* Description       -> Description
*
*
*
*/

#ifndef _WIN32
    #include <avr/io.h>
#endif

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "cmd.h"


/**< Hier befindet sich der "Kommando-Kopf"
 *   Dieser wird bei jedem neuen Senden eines Frames
 *   mit gesendet.
 */
static uint8_t	FrameHeader[ __CMD_HEADER_ENTRYS__ ];

static cmd_t _sInt;

static Crc_t sCrc;

/**< Status Variable, zum erkennen eines neuen Frames. */
static int8_t FrameStart = 0;


/** \brief  CallBack Funktion zum senden des Kommandos
 *          wird in "cmd.h" hinterlegt (z.B uart_put).
 *
 * \param   *pData      -> Zeiger auf Byte(s) Anfang
 * \param   uiLength    -> Länge der Bytes
 * \return  Es wird nichts zurück gegeben
 *
 */
void ( *pCmdSendCallback )			    ( uint8_t *pData , uint8_t uiLength );



static uint8_t      Crc8Message	        ( uint8_t uiCrcStart , uint8_t *pData , uint8_t uiLength )
{
	static uint8_t uiData = 0;

	uiData = uiCrcStart;

	for ( uint8_t ui = 0 ; ui < uiLength ; ui++ )
    {
        uiData = ( uiData ^ pData[ui] );

        for ( uint8_t i = 0; i < 8; i++ )
        {
            if ( ( uiData & 0x80 ) != 0 )
            {
                uiData <<= 1;
                uiData ^= 0x07;
            }
            else
            {
                uiData <<= 1;
            }
        }
    }
	return uiData;
}

static int8_t       FrameSearch	        ( uint8_t *pReceive , uint8_t uiLength )
{
	for ( uint8_t x = 0 ; x < uiLength ; x++ )
	{
		if ( pReceive[x] == '-' )
		{
		  if ( pReceive[x+1] == '+' )
		  {
			return (int8_t)x + 2;
		  }
		  else
		  {
			  return -1;
		  }
		}
	}

	return -1;
}

static Frame_t		FrameGet			( void )
{
	/*
	*	Muss als "static" deklariert sein, sonst können wir uns die
	*	reservierte Adresse von "puiFrame" bei einem erneuten aufruf nicht wieder freigeben.
	*	Das könnte in Verbindung mit "malloc()" Probleme verursachen!
	*/
	static Frame_t sFrame;
	uint8_t ui = 0;

	if ( sFrame.puiFrame != NULL )
    {
		free( sFrame.puiFrame );
	}

	uint8_t	*puiFrame = malloc( __CMD_HEADER_ENTRYS__ + _sInt.uiDataLength );

	if ( puiFrame == NULL )
    {
		return sFrame;
	}

	for ( ; ui < __CMD_HEADER_ENTRYS__ ; ui++ )
    {
		puiFrame[ui] = FrameHeader[ui];
	}

	for ( uint8_t ux = 0 ; ux < _sInt.uiDataLength ; ux++ )
    {
		puiFrame[ui+ux] = _sInt.pData[ux];
	}

	sFrame.puiFrame     = puiFrame;
	sFrame.uiLength     = __CMD_HEADER_ENTRYS__ + _sInt.uiDataLength;
	sFrame.eDataType    = _sInt.uiDataLength;

	return sFrame;
}

static uint8_t	    _FrameBuild		    ( cmd_t *psFrame )
{
	uint8_t uiInfo = 0;

	if ( psFrame->pData == NULL )
    {
		uiInfo = 1<<0; /**< Keine Nutzdaten vorhanden */
	}

	FrameHeader[CMD_HEADER_LENGTH_OF_FRAME]	= (__CMD_HEADER_ENTRYS__ + psFrame->uiDataLength);	// LÃ¤nge der ganzen Antwort
	FrameHeader[CMD_HEADER_DATA_TYP]		= psFrame->eDataType;	// (u)char , (u)int8 , (u)int16 , (u)int32 usw.
	FrameHeader[CMD_HEADER_ID]				= psFrame->eMessageID; // 0..255
	FrameHeader[CMD_HEADER_EXITCODE]		= psFrame->eExitcode;	// 0..255
	FrameHeader[CMD_HEADER_CRC]	            = 0;

	sCrc.uiInternal = 0;

	sCrc.uiInternal = Crc8Message( sCrc.uiInternal , FrameHeader , __CMD_HEADER_ENTRYS__ );

	sCrc.uiInternal = Crc8Message( sCrc.uiInternal , psFrame->pData , psFrame->uiDataLength );

	FrameHeader[CMD_HEADER_CRC] = sCrc.uiInternal;

    _sInt.pData         = psFrame->pData;
	_sInt.uiDataLength  = psFrame->uiDataLength;

	return uiInfo;
}




void		FrameClear			( cmd_t *psFrame )
{
	psFrame->uiDataLength 	= 0;
	psFrame->eDataType		= 0;
	psFrame->eMessageID 	= 0;
	psFrame->eExitcode 	    = 0;
	psFrame->pData 		    = NULL;
}

void		FrameInit			( cmd_t *psFrame )
{
    #ifndef _WIN32
        pCmdSendCallback = _CMD_SEND_CB_FNC_PTR_;
	#endif

	if ( pCmdSendCallback == NULL )
    {
		return;
	}

    FrameClear( psFrame );

	sCrc.uiExternal		= 0;	// Extern resetten
	sCrc.uiInternal		= 0;	// Intern resetten
	FrameStart			= 0;	// Index eines Frames
}

uint8_t		FrameParse			( uint8_t *pReceive , cmd_t *psParsed , uint16_t uiBufferLength )
{
	FrameStart = FrameSearch( pReceive , uiBufferLength );

	if ( FrameStart == - 1 )
    {
		return 1;
	}

	psParsed->uiDataLength 	= pReceive[ FrameStart + CMD_HEADER_LENGTH_OF_FRAME ] -__CMD_HEADER_ENTRYS__;
	psParsed->eDataType		= pReceive[ FrameStart + CMD_HEADER_DATA_TYP		];
	psParsed->eMessageID	= pReceive[ FrameStart + CMD_HEADER_ID				];
	psParsed->eExitcode		= pReceive[ FrameStart + CMD_HEADER_EXITCODE		];
	sCrc.uiExternal			= pReceive[ FrameStart + CMD_HEADER_CRC			 	];

	if ( psParsed->uiDataLength )
    {
		psParsed->pData = pReceive + ( FrameStart + __CMD_HEADER_ENTRYS__ );
	}
	else
	{
		psParsed->pData = NULL; // Keine Nutzdaten
	}

	sCrc.uiInternal = 0;

	pReceive[ FrameStart + CMD_HEADER_CRC ] = 0;

	/**< Checksumme vom empfangenen Frame-Header bilden */
	sCrc.uiInternal = Crc8Message( sCrc.uiInternal , &pReceive[FrameStart] , __CMD_HEADER_ENTRYS__ );

	/**< Checksumme von Rohdaten bilden */
	sCrc.uiInternal = Crc8Message( sCrc.uiInternal , &pReceive[FrameStart + __CMD_HEADER_ENTRYS__ ] , psParsed->uiDataLength );


	/* Checksummen vergleichen */
	if ( sCrc.uiInternal != sCrc.uiExternal )
    {
		return 2;
	}

	return 0;
}

void		FrameBuild		    ( cmd_t *psFrame , enum Cmd_Ident_Enum eIdent , enum Cmd_Data_Type_Enum eDataType , enum Cmd_Exitcodes_Enum eExitcode , uint8_t *pData, uint8_t DataLength )
{
	psFrame->eMessageID	    = eIdent;		// Beschreibt den Nachrichten Typ. Damit die gegenstelle die Nachrichten unterscheiden kann
	psFrame->eDataType		= eDataType;	// Gibt an um welchen Daten Typ es sich handelt
	psFrame->eExitcode		= eExitcode;	// Ruekgabewert einer Funktion
	psFrame->pData			= pData;		// Zeiger auf die Daten die gesendet werden sollen
	psFrame->uiDataLength	= DataLength;	// Anzahl der Bytes

    _FrameBuild( psFrame );
}

void		FrameSend		    ( cmd_t *psFrame )
{
	Frame_t sFrame = FrameGet( );

    pCmdSendCallback( sFrame.puiFrame , sFrame.uiLength );
}

#ifdef _WIN32
void        FrameShow             ( cmd_t *psFrame )
{
    Frame_t sFrame = FrameGet();

    printf("*[CMD_HEADER_LENGTH_OF_FRAME]: 0x%02X\r\n" , sFrame.puiFrame[CMD_HEADER_LENGTH_OF_FRAME]);
    printf("*[CMD_HEADER_DATA_TYP       ]: 0x%02X\r\n" , sFrame.puiFrame[CMD_HEADER_DATA_TYP]);
    printf("*[CMD_HEADER_ID             ]: 0x%02X\r\n" , sFrame.puiFrame[CMD_HEADER_ID]);
    printf("*[CMD_HEADER_EXITCODE       ]: 0x%02X\r\n" , sFrame.puiFrame[CMD_HEADER_EXITCODE]);
    printf("*[CMD_HEADER_CRC            ]: 0x%02X\r\n" , sFrame.puiFrame[CMD_HEADER_CRC]);

    for ( uint8_t ui = 0 ; ui < (sFrame.uiLength - __CMD_HEADER_ENTRYS__) ; ui++ )
    {
         printf("*[Data                      ]: 0x%02X\r\n" , sFrame.puiFrame[__CMD_HEADER_ENTRYS__ + ui ]);
    }
}
#endif
