/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> Error Handling
* Version           -> 1.0.0.0528
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 28.05.2018 06:38:46
* Description       -> Description
*
*	Aufbau des Fehlerspeichers.:
*
*
*	z.B.:	SLOT ( max. ERROR_SLOTS )	|	Errorcode ( max. ERROR_BUFFER_MASK )
*		   +------------------------+	|  +-----------------------------------+
*			0							| 	1 , 4 , 2 , 5 , 1
*			1							| 	5 , 7 , 8 , 32 , 212
*			...							|
*
*
*	- Jeder einzelne Slot arbeitet nach dem "LIFO" Prinzip		
*
*
*
*/


#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>

#include "error.h"


#if ( ERROR_BUFFER_LENG & ERROR_BUFFER_MASK )
#error Buffer size is not power of nÂ²
#endif



void ErrorInit( void )
{
	for( uint8_t ui = 0 ; ui < ERROR_SLOTS ; ui++ )
	{
		sError[ui].uiRead = 0;
		sError[ui].uiWrite = 0;
		for( uint8_t ux = 0 ; ux < ERROR_BUFFER_LENG ; ux++ )
		{
			sError[ui].pBuffer[ux] = 0;
		}
	}
}

enum Error_Return_Codes_Enum ErrorWrite( uint8_t uiSlot , uint8_t uiError )
{
	if( uiSlot > ERROR_SLOTS ){
		return ERROR_RETURN_SLOTS_OVF;		
	}
	
	uint8_t uiNextPosition = ( ( sError[uiSlot].uiWrite + 1 ) & ERROR_BUFFER_MASK );
	
//	if( sError[uiSlot].uiRead == uiNextPosition ){
//		return ERROR_RETURN_SLOTS_FULL;
//	}
    
	sError[uiSlot].pBuffer[sError[uiSlot].uiWrite] = uiError;
	
	sError[uiSlot].uiWrite = uiNextPosition;
	
	return ERROR_RETURN_SLOTS_OK;
}

enum Error_Return_Codes_Enum ErrorRead( uint8_t uiSlot , uint8_t *pByte )
{
	if( uiSlot > ERROR_SLOTS ){
		return ERROR_RETURN_SLOTS_OVF;		
	}

  	if ( sError[uiSlot].uiRead == sError[uiSlot].uiWrite ){
  		*pByte = 0;
		return ERROR_RETURN_SLOTS_EMPTY;
	}
    
  	*pByte = sError[uiSlot].pBuffer[ sError[uiSlot].uiRead ];

	sError[uiSlot].uiRead = ( ( sError[uiSlot].uiRead + 1 ) & ERROR_BUFFER_MASK );
	
	return ERROR_RETURN_SLOTS_OK;
}


