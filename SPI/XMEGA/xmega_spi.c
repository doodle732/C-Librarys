/* Generated by CodeDescriptor 1.0.0.0 */
/*
* Project Name      -> XMEGA - SPI Driver
* Version           -> 1.0
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 16.06.2017 08:35:29
* Description       -> Driver for XMEGA(s)
*
*
*
*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include "../Headers/xmega_spi.h"


static spiIO_t spi;
static spiIO_t spiUsartx;

spiIO_t *spiIO		= &spi;
spiIO_t *spiUsart	= &spiUsartx;

void spiMasterInit( spiIO_t *s , spiPrescaler_enum pres , uint8_t doubleSpeed , spiMode_enum mode , spiDataOrder_enum order , spiInterruptLvl_enum intlvl )
{
 	s->ports.spi->DIRSET	= (1<<s->bitPos.mosi);
 	s->ports.spi->DIRSET	= (1<<s->bitPos.sck);
 	s->ports.spi->DIRCLR	= (1<<s->bitPos.miso);
	
	s->ports.spi->DIRSET = 1<<4;
	s->ports.spi->OUTSET = 1<<4;
		

	if ( doubleSpeed )
	{
		switch( pres )
		{
			case SPI_PRESCALER_DBL_SPEED_2:		
			{
				s->spiUnit->CTRL |= SPI_CLK2X_bm | SPI_PRESCALER_DIV2_gc;
			}break;
			
			case SPI_PRESCALER_DBL_SPEED_8:		
			{
				s->spiUnit->CTRL |= SPI_CLK2X_bm | SPI_PRESCALER_DIV8_gc;
			}break;
			
			case SPI_PRESCALER_DBL_SPEED_32:	
			{
				s->spiUnit->CTRL |= SPI_CLK2X_bm | SPI_PRESCALER_DIV32_gc;
			}break;
			
			default:	
			{
				s->spiUnit->CTRL |= SPI_PRESCALER_DIV128_gc;
			}break;
		}
	}
	else
	{
		switch( pres )
		{
			case SPI_PRESCALER_4:		
			{
				s->spiUnit->CTRL |= SPI_PRESCALER_DIV4_gc;
			}break;
			
			case SPI_PRESCALER_16:	
			{
				s->spiUnit->CTRL |= SPI_PRESCALER_DIV16_gc;
			}break;
			
			case SPI_PRESCALER_64:	
			{
				s->spiUnit->CTRL |= SPI_PRESCALER_DIV64_gc;
			}break;
			
			case SPI_PRESCALER_128:	
			{
				s->spiUnit->CTRL |= SPI_PRESCALER_DIV128_gc;
			}break;
			
			default:	
			{
				s->spiUnit->CTRL |= SPI_PRESCALER_DIV128_gc;
			}break;
		}		
	}
	
	switch( mode )
	{
		case SPI_MODE_0:
		{
			s->spiUnit->CTRL |= SPI_MODE_0_gc;
		}break; // Rising, sample  | Falling, setup
		
		case SPI_MODE_1:
		{
			s->spiUnit->CTRL |= SPI_MODE_1_gc;
		}break; // Rising, setup   | Falling, sample
		
		case SPI_MODE_2:		
		{
			s->spiUnit->CTRL |= SPI_MODE_2_gc;
		}break; // Falling, sample | Rising, setup
		
		case SPI_MODE_3:
		{
			s->spiUnit->CTRL |= SPI_MODE_3_gc;
		}break; // Falling, setup  | Rising, sample
		
		default:	
		{
			s->spiUnit->CTRL |= SPI_MODE_3_gc;
		}break; // Falling, setup  | Rising, sample
	}
	
	switch( order )
	{
		case SPI_MSB_FIRST:
		{
			s->spiUnit->CTRL |= SPI_DORD_bm;
		}break;
			
		case SPI_LSB_FIRST:
		{
			s->spiUnit->CTRL &= ~(SPI_DORD_bm);
		}break;
	
		default:
		{
			s->spiUnit->CTRL |= SPI_DORD_bm;
		}	
	}
	
	s->spiUnit->CTRL |= SPI_MASTER_bm; // Master Mode
	
	switch( intlvl )
	{
		case SPI_INT_LVL_LOW:		
		{
			s->spiUnit->CTRL |= SPI_INTLVL_LO_gc;
		}break; // Interrupt Level = Low
		
		case SPI_INT_LVL_MEDIUM:		
		{
			s->spiUnit->CTRL |= SPI_INTLVL_MED_gc;
		}break; // Interrupt Level = Medium
		
		case SPI_INT_LVL_HIGH:		
		{
			s->spiUnit->CTRL |= SPI_INTLVL_HI_gc;
		}break; // Interrupt Level = High
		
		default:	
		{
			s->spiUnit->CTRL |= SPI_INTLVL_MED_gc;
		}; // Interrupt Level = Medium
	}
	
	s->spiUnit->CTRL |= SPI_ENABLE_bm; // SPI Enable
}

void spiMasterWrite( uint8_t byte )			
{
	spiIO->spiUnit->DATA = byte;
	SPI_WHILE_TX_COMPLETE();
}

uint8_t spiMasterRead( void )				
{
	SPI_WHILE_TX_COMPLETE();
	return spiIO->spiUnit->DATA;
}

uint8_t spiMasterWriteRead( uint8_t byte )	
{
	spiIO->spiUnit->DATA = byte;
	SPI_WHILE_TX_COMPLETE();
	return spiIO->spiUnit->DATA;
}


void spiUsartxInit( spiIO_t *usartx , uint32_t baud , usartxSpiMode_enum mode , usartxSpiDataOrder_enum dataOrder )	
{
	usartx->ports.spi->DIRSET			= (1<<usartx->bitPos.mosi);
	usartx->ports.spi->DIRSET			= (1<<usartx->bitPos.sck);
	
	usartx->ports.spi->DIRCLR			= (1<<usartx->bitPos.miso);

		
	/* master spi mode */
	usartx->usartUnit->CTRLC			= USART_CMODE_MSPI_gc;
	
 	/* set baudrate */
	usartx->usartUnit->BAUDCTRLA		= SPI_USART_CALC_BSEL( baud ) & 0x00FF;
	usartx->usartUnit->BAUDCTRLB		= ( SPI_USART_CALC_BSEL( baud ) & 0x0F00 ) >> 8;
	
	switch ( dataOrder )
	{
		case USART_SPI_LSB_FIRST:
		{
			usartx->usartUnit->CTRLC |= ( 1<<USARTx_UDORD_bp ); // lsb first
		}break;
		
		case USART_SPI_MSB_FIRST:
		{
			usartx->usartUnit->CTRLC &= ~( 1<<USARTx_UDORD_bp ); // msb first
		}break;
		
		default: 
		{
			usartx->usartUnit->CTRLC |= ( 1<<USARTx_UDORD_bp ); // lsb first
		}
	}

	
	/* set spi mode */
	switch ( mode )
	{
		case USART_SPI_MODE0: // Rising, sample  | Falling, setup
		{
			usartx->ports.spi->PIN1CTRL &= ~( PORT_INVEN_bm ); // clear inverted mode
			usartx->usartUnit->CTRLC	&= ~( 1<<USARTx_UCPHA_bp );
		}break; // mode 0
			
		case USART_SPI_MODE1: // Rising, setup   | Falling, sample
		{
			usartx->ports.spi->PIN1CTRL &= ~( PORT_INVEN_bm ); // clear inverted mode
			usartx->usartUnit->CTRLC	|=  ( 1<<USARTx_UCPHA_bp );
		}break; // mode 1
			
		case USART_SPI_MODE2: // Falling, sample | Rising, setup
		{
			usartx->ports.spi->PIN1CTRL |=  (PORT_INVEN_bm); // set inverted mode
			usartx->usartUnit->CTRLC	&= ~(1<<USARTx_UCPHA_bp);
		}break; // mode 2
			
		case USART_SPI_MODE3: // Falling, setup  | Rising, sample
		{
			usartx->ports.spi->PIN1CTRL |= (PORT_INVEN_bm); // set inverted mode
			usartx->usartUnit->CTRLC	|= (1<<USARTx_UCPHA_bp);
		}break; // mode 3
			
		default: // Falling, setup  | Rising, sample
		{
			usartx->ports.spi->PIN1CTRL |= (PORT_INVEN_bm); // set inverted mode
			usartx->usartUnit->CTRLC	|= (1<<USARTx_UCPHA_bp);
		}break; // mode 3
	}

	PR.PRPC &= ~PR_USART0_bm; // enable USART
	
 	/* enable spi receive enable & transmit enable */
 	usartx->usartUnit->CTRLB |= ( ( 1<<USARTx_RXEN_bp ) | ( 1<<USARTx_TXEN_bp ) );
}

void spiUsartxWrite( uint8_t byte )														
{
	SPI_USARTX_WAIT_DATA_REGISTER_IS_EMPTY()
	spiUsart->usartUnit->DATA = byte;
}

uint8_t spiUsartxRead( void )															
{
	SPI_USARTX_WAIT_RECEIVE_INTERRUPT()
	return spiUsart->usartUnit->DATA;
}

uint8_t spiUsartxWriteRead( uint8_t byte )												
{
  SPI_USARTX_WAIT_DATA_REGISTER_IS_EMPTY()
  spiUsart->usartUnit->DATA = byte;
  
  SPI_USARTX_WAIT_RECEIVE_INTERRUPT()
  return spiUsart->usartUnit->DATA;
}


/* SPI Interrupt Handler
*/
ISR(SPIC_INT_vect)																		
{
}