/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> WSQ 3000
* Version           -> 1.0.0.0813
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 13.08.2018 10:10:01
* Description       -> Timer
*
*	Wichtig! Sollte irgendein Interrupt aktiviert sein,
*	muss unbedingt der dazugehörige Vektor im Quellkode vorhanden sein. 
*
*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdlib.h>



void		timerOVFInit			( tcxOvfInit_t *i )	
{
	if ( i->tim0 )
	{
		i->tim0->CTRLA		= i->tim0Cnfg.preVal;										// Takt konfigurieren ( mit ggf. Vorteiler )
		i->tim0->PER		= TIMER_CALC_HZ( i->tim0Cnfg.preVal	, i->tim0Cnfg.hz );	// Interupt Überlauf berechnen
		i->tim0->INTCTRLA	= TC_OVFINTLVL_HI_gc;										// Interrupt "Overflow" aktivieren / Priorität des Interrupts festlegen
	}
	
	if ( i->tim1 )
	{
		i->tim1->CTRLA		= i->tim1Cnfg.preVal;										// Takt konfigurieren ( mit ggf. Vorteiler )
		i->tim1->PER		= TIMER_CALC_HZ( i->tim1Cnfg.preVal	 , i->tim1Cnfg.hz );	// Interupt Überlauf berechnen
		i->tim1->INTCTRLA	= TC_OVFINTLVL_HI_gc;										// Interrupt "Overflow" aktivieren / Priorität des Interrupts festlegen		
	}
	
	PR.PRPC = 0x00;														// Power einschalten
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;  // Interrupts freigeben ( sei() muss trodzdem sein! )	

	sei();
}

void		timerCMPInit			( tcxInit_t *i )	
{		
	/*
	*	Hier wird ohne Hardware Pin Toggeln gearbeitet. Sollte von 
	*	außen der entsprechende Hardware Pin getoggelt werden, muss
	*	in das CTRLB Register ( ATXMEGA256A3BU ) noch TCx_CCxEN_bm gesetzt werden.
	*/
	if ( i->tim0 )
	{
		i->tim0->CTRLA											= i->tim0Cnfg.preVal;										// Takt konfigurieren ( mit ggf. Vorteiler )
		i->tim0->CTRLB											= TC_WGMODE_FRQ_gc;											// Compare Match 'A' aktivieren	
		i->tim0->INTCTRLB										= TC_CCAINTLVL_HI_gc;										// Interrupt "Compare Match" aktivieren / Priorität des Interrupts festlegen	
		TIMER_CCx( i->tim0 , i->tim0Cnfg.compareMatchChannel )	= TIMER_CALC_HZ( i->tim0Cnfg.preVal , i->tim0Cnfg.cmpVal );	// Compare Match Wert
	}
	
	if ( i->tim1 )
	{
		i->tim1->CTRLA											= i->tim1Cnfg.preVal;										// Takt konfigurieren ( mit ggf. Vorteiler )
		i->tim1->CTRLB											= TC_WGMODE_FRQ_gc;											// Compare Match 'A' aktivieren
		i->tim1->INTCTRLB										= TC_CCAINTLVL_HI_gc;										// Interrupt "Compare Match" aktivieren / Priorität des Interrupts festlegen		
		TIMER_CCx( i->tim1 , i->tim1Cnfg.compareMatchChannel )	= TIMER_CALC_HZ( i->tim1Cnfg.preVal , i->tim1Cnfg.cmpVal );	// Compare Match Wert
	}

	PR.PRPC	= 0x00;													    // Power einschalten
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;	// Interrupts freigeben ( sei() muss trodzdem sein! )
	
	sei();
}

void		timerPWMInit			( tcxInit_t *i )	
{
	if ( i->tim0 )
	{
		i->tim0->CTRLA											= i->tim0Cnfg.preVal; // Takt konfigurieren ( mit ggf. Vorteiler )
		i->tim0->CTRLB											= ( TC_WGMODE_SINGLESLOPE_gc | ( TC0_CCAEN_bm << i->tim0Cnfg.compareMatchChannel  ) ); // Compare Match 'A' aktivieren	
		i->tim0->PER											= i->tim0Cnfg.perVal; // Maximaler Zählerwert von TIMERx															
		TIMER_CCx( i->tim0 , i->tim0Cnfg.compareMatchChannel )	= i->tim0Cnfg.cmpVal; // Compare Match Wert	
	}
	
	if ( i->tim1 )
	{
		i->tim1->CTRLA											= i->tim1Cnfg.preVal; // Takt konfigurieren ( mit ggf. Vorteiler )
		i->tim1->CTRLB											= ( TC_WGMODE_SINGLESLOPE_gc | ( TC1_CCAEN_bm << i->tim1Cnfg.compareMatchChannel  ) ); // Compare Match 'A' aktivieren
		i->tim1->PER											= i->tim1Cnfg.perVal; // Maximaler Zählerwert von TIMERx		
		TIMER_CCx( i->tim1 , i->tim1Cnfg.compareMatchChannel )	= i->tim1Cnfg.cmpVal; // Compare Match Wert
	}

	sei();	
}


uint8_t		timerSetCompareValue	( TC0_t *tim0 , TC1_t *tim1 , uint8_t ccx , uint16_t val )	
{
	if ( ccx > 3 ) return 1; // Register nicht vorhanden..
	
	if ( tim0 )
	{
		TIMER_CCx( tim0 , ccx ) = val;
	}
	
	if ( tim1 )
	{
		TIMER_CCx( tim1 , ccx ) = val;
	}
	
	return 0;
}

void		timerStart				( TC0_t *tim0 , tcxPrescaler_t pre0 , TC1_t *tim1 , tcxPrescaler_t pre1 )	
{
	if ( tim0 )
	{
		tim0->CTRLA = pre0;
	}
	
	if ( tim1 )
	{
		tim1->CTRLA = pre1;
	}
}

void		timerStop				( TC0_t *tim0 , TC1_t *tim1 )	
{
	if ( tim0 )
	{
		tim0->CTRLA = TIMER_PRESCALER_OFF;
	}
	
	if ( tim1 )
	{
		tim1->CTRLA = TIMER_PRESCALER_OFF;
	}	
}




