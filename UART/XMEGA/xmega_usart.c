/* Generated by CodeDescriptor 1.0.0.0 */
/*
* Project Name      -> XMEGA - USART Driver
* Version           -> 1.0
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 16.06.2017 10:02:55
* Description       -> XMEGA USART Driver
*
*
*
*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdlib.h>

#include "../Headers/xmega_usart.h"
#include "../Headers/wsq3000_def.h"


static volatile unsigned char USART_TxBuf[USART_TX_BUFFER_SIZE];
static volatile unsigned char USART_RxBuf[USART_RX_BUFFER_SIZE];
static volatile unsigned char USART_TxHead;
static volatile unsigned char USART_TxTail;
static volatile unsigned char USART_RxHead;
static volatile unsigned char USART_RxTail;
static volatile unsigned char USART_LastRxError;

/*
*	Hier nichts ändern!
*/
usart_baud_setting	baudCnfg32mhz[] =	
{
	/*
	*	Die Einstellungen sind für eine Frequenz von 32MHz gedacht!
	*/
	
	/* BSEL | BSCALE */
	{ 12 , 7	}, // 2400Baud
	{ 12 , 6	}, // 4800Baud
	{ 12 , 5	}, // 9600Baud
	{ 138 , 1	}, // 14.4kBaud
	{ 12 , 4	}, // 19.2kBaud
	{ 138 , 0	}, // 28.8kBaud
	{ 12 , 3	}, // 38.4kBaud
	{ 137 , -1	}, // 57.6kBaud
	{ 12 , 2	}, // 76.8kBaud
	{ 135 , -2	}, // 115.2kBaud
	{ 131 , -3	}, // 230.4kBaud
	{ 123 , -4	}, // 460.8kBaud
	{ 107 , -5	}, // 921.6kBaud
	{ 121 , -6	}, // 1.382Mbaud
	{ 75 , -6	}, // 1.843Mbaud
	{ 1 , 0		}, // 2Mbaud
};

usart_baud_setting	baudCnfg2mhz[] =	
{
	/*
	*	Die Einstellungen sind für eine Frequenz von 2MHz gedacht!
	*/
	
	/* BSEL | BSCALE */
	{ 103 , 0	}, // 2400Baud
	{ 25 , 1	}, // 4800Baud
	{ 12 , 1	}, // 9600Baud
	{ 131 , -3	}, // 14.4kBaud
	{ 192 , -4	}, // 19.2kBaud
	{ 123 , -4	}, // 28.8kBaud
	{ 22 , -2	}, // 38.4kBaud
	{ 107 , -5	}, // 57.6kBaud
	{ 9 , -2	}, // 76.8kBaud
	{ 75 , -6	}, // 115.2kBaud	
};




void	usartInit		( USART_t *usart , usart_baudrates_enum baud )	
{
	if ( !usart ) return;

    USART_RxHead = 0;
    USART_RxTail = 0;
	
	#ifdef F_CPU
	
		#if		F_CPU == 32000000
		
			usart->BAUDCTRLB = baudCnfg32mhz[baud].bscale << 4;
			usart->BAUDCTRLA = baudCnfg32mhz[baud].bsel;
	
		#elif	F_CPU == 2000000
		
			if ( baud > BAUD_115200 ) // höhere Baudraten schafft man mit 2MHz nicht
			{
				usart->BAUDCTRLB = baudCnfg2mhz[BAUD_115200].bscale << 4;
				usart->BAUDCTRLA = baudCnfg2mhz[BAUD_115200].bsel;
			}
			else
			{
				usart->BAUDCTRLB = baudCnfg2mhz[baud].bscale << 4;
				usart->BAUDCTRLA = baudCnfg2mhz[baud].bsel;
			}
			
		#else
		
			#warning <F_CPU wird nicht unterstuetzt..!>
			
		#endif
	#else
	
		#warning <F_CPU nicht definiert..!>
		
	#endif
	


	usart->CTRLA	 = USART_RXCINTLVL_HI_gc;
	usart->CTRLB	 = USART_TXEN_bm | USART_RXEN_bm | USART_CLK2X_bm;
	usart->CTRLC	 = USART_CHSIZE_8BIT_gc;
	
	USART_PORT.DIRSET	= ( 1 << USART_TX_bp );
	USART_PORT.DIRCLR	= ( 1 << USART_RX_bp );

	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;	
	
	sei();
}

void	usartPutChar	( char c )		
{
   	//while ( ! ( USARTxx.STATUS & USART_DREIF_bm ) );
   	//USARTxx.DATA = c;
	   
    unsigned char tmphead;

    
    tmphead  = (USART_TxHead + 1) & USART_TX_BUFFER_MASK;
    
    while ( tmphead == USART_TxTail ){
	    ;/* wait for free space in buffer */
    }
    
    USART_TxBuf[tmphead] = c;
    USART_TxHead = tmphead;

    /* enable UDRE interrupt */
    USARTxx.CTRLA    |= ( USART_DREINTLVL_HI_gc );
}

void	usartPutStr		( char *str )	
{	
	while( *str )
	{ 
		usartPutChar( *str++ );
	}
}
	
uint16_t usartGetChar	( void )		
{
    unsigned char tmptail;
    unsigned char data;

    if ( USART_RxHead == USART_RxTail ) 
	{
	    return USART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (USART_RxTail + 1) & USART_RX_BUFFER_MASK;
    USART_RxTail = tmptail;
    
    /* get data from receive buffer */
    data = USART_RxBuf[tmptail];
    
    return data;
}




ISR( USART_RX_INT )					
{	
    unsigned char tmphead;
    unsigned char data;
	
	data = USARTxx.DATA;	
	
    /* calculate buffer index */
    tmphead = ( USART_RxHead + 1) & USART_RX_BUFFER_MASK;
    
    if ( tmphead == USART_RxTail ) 
	{
	    /* error: receive buffer overflow */
	}
	else
	{
	    /* store new index */
	    USART_RxHead = tmphead;
	    /* store received data in buffer */
	    USART_RxBuf[tmphead] = data;
    }	
}

ISR( USART_DRE_INT )				
{
    unsigned char tmptail;
	
    if ( USART_TxHead != USART_TxTail) 
	{
	    /* calculate and store new buffer index */
	    tmptail = (USART_TxTail + 1) & USART_TX_BUFFER_MASK;
	    USART_TxTail = tmptail;
	    /* get one byte from buffer and write it to UART */
	    USARTxx.DATA = USART_TxBuf[tmptail];  /* start transmission */
	}
	else
	{
	    /* tx buffer empty, disable UDRE interrupt */
	    USARTxx.CTRLA    &= ~( USART_DREINTLVL_HI_gc );
    }
}

ISR( USART_TX_INT )					
{
}



	
