/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> Kommando Interpreter
* Version           -> 1.0.1.1124
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 20.09.2017 07:50:01
* Description       ->
*
*
*	<!-- ++ Frame Header Aufbau ++-->
*
*	+----------+ +------+ +------+ +------+ +------+ +------+ 		+----------------------------------------------+
*	|'-' | '+ '|-| 0x05 |-| 0x01 |-| 0x04 |-| 0x00 |-| 0x32 |	-	| 0..n ( max. 255 - __FRAME_ENTRYS__ )  Bytes) |
*	+----------+ +------+ +------+ +------+ +------+ +------+ 		+----------------------------------------------+
*		 ^			^		 ^		   ^		^		 ^				  ^
*		 |			|		 |		   |		|		 |				  |
*	Startzeichen    |	  Datentyp	   |	Exitcode	 |			  Nutzdaten
*					|				   |				 |			  Anmerkung: Bei Datentypen > uint8_t
*			Länge des gesamten		   |			Checksumme		  wird das LSB zuerst gesendet.
*			Telegrammes				   |
*			(ohne				Telegramm Identifikation
*            Startzeichen!)
*
*	-!> Startzeichen: Wird zur Erkennung eines eingehenden Telegrammes benutzt. Je nachdem wie man es auf der Empfangsseite
*		implementiert können die "Startzeichen" auch weggelassen werden.
*
*	-!> Länge: Setzt sich aus der Anzahl von Bytes des "Frame Headers" und der "Nutzdaten" zusammen.
*	   > Bsp.: Frame Header Bytes = 5 + Nutzdaten Bytes = 10. Also ist die Länge des ganzen Telegrammes "15" Bytes groß.
*
*	-!> Datentyp: Siehe "frame_types.h".
*
*	-!> Telegramm Identifikation: Dient zum auseinander halten der einzelnen Nachrichten oder um dem Telegramm eine Priorität
*		zu verpassen. Die Identifikationen können in "frame_id.h" hinterlegt werden.
*
*	-!> Exitcode: Wird das Telegramm z.B ohne Nutzdaten gesendet und führt dazu das "nur" eine Funktion ausgeführt werden soll,
*		so kann hier (wenn vorhanden) der Rückgabecode der Funktion eingefügt werden.
*
*	-!> Checksumme: Hier sind einige Sachen zu beachten. Die Checksumme wird erst von dem "Frame Header" gebildet!
*		Die "Checksumme" beträgt während der bildung den Wert Dez. '0'. Danach wird mit der zuvor berechneten Checksumme
*		der Rest berechnet, die Nutzdaten! Nach erfolgreicher Berechnung wird die "Checksumme" in das dafür vorgesehene 
*		Datenfeld kopiert. Auf der Empfangsseite wird genau das gleiche gemacht.
*
*	-!> Nutzdaten: Sollte es um einen Datentyp gehen der > 1 Byte ist, wird das LSB zuerst gesendet.
*		Die Länge der Nutzdaten ist eingeschränkt! Da der Parameter "Länge" (vom Frame Header) bis jetzt nur Werte von 0-255 
*		aufnehmen kann, sprich 1 Byte groß ist muss von der Länge der Nutzdaten noch die Anzahl der "__FRAME_ENTRYS__" 
*		abgezogen werden. Aktuell würden es dann nur max. 250 Bytes sein die als Nutzdaten verschickt werden können.
*/

#ifndef __FRAME_H__
#define __FRAME_H__

#include <stdint.h>
#include <stdlib.h>

#include "types.h"
#include "exitcodes.h"
#include "frame_id.h"

#ifndef _WIN32
    #include "uart.h"
#endif

#ifndef NULL
	#define NULL 0
#endif


/*
*	Callback Funktion zum senden von Frames..
*	2 Parameter müssen übergeben werden ->
*
*	1 = Zeiger auf Daten ( *uint8_t )
*	2 = Länge
*/
#ifndef _WIN32
    #define _CMD_SEND_CB_FNC_PTR_		uartPutByteStr
#endif


enum eFrameDesc
{
	FRAME_LENGTH_OF_FRAME,  /**< Länge des gesamten Frames */
	FRAME_DATA_TYP, 		/**< Welcher Datentyp wird versendet */
	FRAME_ID, 				/**< Frame Identifikation */
	FRAME_EXITCODE,		    /**< Rückgabewert von Funktion */
	FRAME_CRC, 			    /**< Checksumme von der ganzen Nachricht */

	__FRAME_ENTRYS__
};

enum eFrameError
{
	FRAME_ERROR_NO_DATA_PTR = 1<<0,	
};

typedef struct
{
    /**< Datentyp der Nutzdaten im Frame */
	enum eDataType	eDataType;

    /**< Gibt an um welche Art Frame es sich handelt */
	enum eIdent	    eMessageID;

    /**< Funktions Rückgabe Code */
	enum eExitcodes	eExitcode;

    /**< Nutzdaten */
	uint8_t *pData;

    /**< Laenge der Nutzdaten */
	uint8_t uiDataLength;

	/**< Auftretene Fehler */
	enum eFrameError eFrameError;

}sFrameDesc_t;

typedef struct
{
    /**< Zeiger auf den Anfang des Frames */
	uint8_t *puiFrame;

	/**< Länge des kompletten Frames */
	uint8_t uiLength;

    /**< Gesendete Datentyp */
	enum eDataType	eDataType;

}sFrame_t;

typedef struct
{
    /**< Intern berechnete Checksumme */
	uint8_t uiInternal;

    /**< Extern berechnete Checksumme */
	uint8_t uiExternal;

}sCrc_t;


void				FrameInit			( void );

void				FrameClear			( void );

uint8_t				FrameParse			( uint8_t *pReceive , sFrameDesc_t *psFrame , uint16_t uiBufferLength );

sFrameDesc_t		FrameBuild		    ( enum eIdent eIdent , enum eDataType eDataType , enum eExitcodes eExitcode , uint8_t *pData, uint8_t uiDataLength );

void				FrameSend   		( sFrameDesc_t *psFrame );



/**< DEBUG */

#ifdef _WIN32
    void			FrameShow      ( sFrameDesc_t *psFrame );
#endif

#endif // __FRAME_H__
