/* Generated by CodeDescriptor 1.3.0.0714 */
/*
* Project Name      -> ST7565R
* Version           -> 1.0.1.0816
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 16.08.2017 07:08:38
* Description       -> Description
*
*
*
*/

#include "../Headers/wsq3000_def.h"

#include <avr/io.h>
#include <avr/interrupt.h>
#include <string.h>
#include <util/delay.h>
#include "../Headers/st7565r.h"
#include "../Headers/xmega_spi.h"


font_t font;

/* ONLY FOR INTERNAL OPERATIONAL */
static inline uint8_t swapBits	(uint8_t byte)							
{
	uint8_t ret = 0;
	
	for ( uint8_t i = 0 ; i < 8 ; i++ )
	{
		ret >>= 1;
		ret |= byte & 0x80;
		byte <<= 1;
	}
	return ret;
}

uint8_t calcXWidth				( uint8_t x )							
{
	return (font.fontPtr[2] * x);
}

void	glcdSendData			( uint8_t byte )						
{
	GLCD_CTR_CS_PORT		&= ~(1<<GLCD_CTR_CS_bp);	// CS	= 0
	GLCD_CTR_A0_PORT		|=  (1<<GLCD_CTR_A0_bp);	// A0	= 1
	
	spiUsartxWriteRead( byte );		

	GLCD_CTR_CS_PORT |= (1<<GLCD_CTR_CS_bp);			// CS = 1
}

void	glcdSendCmd				( uint8_t cmd )							
{
	GLCD_CTR_CS_PORT		&= ~(1<<GLCD_CTR_CS_bp);	// CS	= 0
	GLCD_CTR_A0_PORT		&= ~(1<<GLCD_CTR_A0_bp);	// A0	= 0

	spiUsartxWriteRead( cmd );
	
	GLCD_CTR_CS_PORT |= (1<<GLCD_CTR_CS_bp);			// CS	= 1
}

void	glcdInit				( void )								
{
	/* GLCD unit */
	GLCD_CTR_A0_DDR			|= ( 1<<GLCD_CTR_A0_bp );
	GLCD_CTR_CS_DDR			|= ( 1<<GLCD_CTR_CS_bp );
	GLCD_CTR_SCK_DDR		|= ( 1<<GLCD_CTR_SCK_bp );
	GLCD_CTR_SD_DDR			|= ( 1<<GLCD_CTR_SD_bp );
	GLCD_CTR_RESET_DDR		|= ( 1<<GLCD_CTR_RESET_bp );

	GLCD_CTR_CS_PORT		&= ~( 1<<GLCD_CTR_CS_bp );	// CS	= 0
	_delay_ms(5);

	GLCD_CTR_RESET_PORT		&= ~( 1<<GLCD_CTR_RESET_bp );		// RST	= 0
	_delay_ms(10);
	GLCD_CTR_RESET_PORT		|= ( 1<<GLCD_CTR_RESET_bp );		// RST	= 1

	for( uint8_t i = 0 ; i < sizeof( glcd_config ) ; i++ )
	{
		glcdSendCmd( glcd_config[i] );
	}
	
	glcdClear();
}

void	glcdSetPageColumn		( uint8_t pageAddr , uint8_t column )	
{
    glcdSendCmd( ( ( pageAddr & 0x0F ) | 0xB0 ) );
     
    /*
    *   Baue das Kommando für die Zeile (High Byte)
    */
    glcdSendCmd( ( ( ( column & 0xF0 ) >> 4 ) ) | 0x10 );
     
    /*
    *   Adresse (Low Byte)
    */
    glcdSendCmd( column & 0x0F );
}

void	glcdSendBuffer			( uint8_t *image )						
{
	/*
	*	Buffer Size = GLCD_HIGH_SIZE * GLCD_WIDTH_SIZE = 8092 Bytes
	*/
	for ( uint8_t i = 0 ; i < GLCD_PAGE_SIZE ; i++ )
	{
		glcdSetPageColumn( 7 - i  , 0 );
		for ( uint8_t x = 0 ; x < GLCD_WIDTH_SIZE ; x++ )
		{
			glcdSendData( image[x] );
		}
		image += GLCD_WIDTH_SIZE;
	}
}


void	glcdFill				( void )								
{
	for ( uint8_t page = 0 ; page < GLCD_PAGE_SIZE ; page++ )
	{
		glcdSetPageColumn(page,0);
		for ( uint8_t col = 0 ; col < GLCD_WIDTH_SIZE ; col++ )
		{
			glcdSendData( 0xFF );
		}
	}
}

void	glcdClear				( void )								
{
	for ( uint8_t page = 0 ; page < GLCD_PAGE_SIZE ; page++ )
	{
		glcdSetPageColumn( page , 0 );
		for ( uint8_t col = 0 ; col < GLCD_WIDTH_SIZE ; col++ )
		{
			glcdSendData( 0x00 );
		}
	}
}

void	glcdReset				( void )								
{
	glcdSendCmd( CMD_INTERNAL_RESET );
}



static inline font_t calcFontStart	(uint8_t c, font_t font, const uint8_t __flash *fontPtr)							
{		
	uint8_t charNum = 0;
	
	font.width = fontPtr[ ( c - font.fontPtr[FONT_FIRST_CHAR] ) + font.fontPtr[FONT_BEGINN_RAW_DATA] ]; // Zeichenbreite berechnen
	
	font.indexNum = font.fontPtr[FONT_BEGINN_RAW_DATA]; // Offset (ab hier beginnen die reinen Pixel Daten)
	
	/*
	*	Besitzt das Font eine feste Breite?
	*/
	if ( font.fontPtr[FONT_FONT_FIXED] )
 	{
		 font.indexNum += ( c * font.fontPtr[FONT_CHAR_WIDTH] );
	}
	else
	{
		/*
		*	Vor den eigentlichen "Pixeldaten" stehen die Breiten des jeweiligen Zeichen.
		*	Diese breiten müssen solange summiert werden bis das aktuelle Zeichen z.B
		*
		*	0 (ASCII) = 48 (Dezimal), nun müssen wir 48 die Breiten der vorherigen Zeichen
		*	summieren damit wir den Index vom gewünschten Zeichen ( hier 0 ) erhalten.
		*
		*/
  		for(	; charNum < ( c - font.fontPtr[FONT_FIRST_CHAR] ) ; charNum++ )
		{
  			font.indexNum += ( fontPtr[charNum + font.fontPtr[FONT_BEGINN_RAW_DATA] ] << 1); // Anstatt *2, schieben wir hier einfach			
		}
	}
	
	return font;
}

void glcdPrintImage					(const __flash unsigned char *image, uint16_t sizeofimage, uint8_t x, uint8_t y)	
{	
 	uint16_t column = image[BITMAP_BEGINN_RAW_DATA];
	uint16_t page	= 0;
	
	glcdSetPageColumn( ( x / 8 ) , y );
	for ( ; page < ( ( image[BITMAP_HIGH] / 8 ) + 2 ) ; page++ )
	{
		for ( ; column < ( uint16_t ) ( ( image[BITMAP_WIDTH] * page ) + image[BITMAP_BEGINN_RAW_DATA] ) && ( column < sizeofimage ) ; column++ )
		{
			glcdSendData( swapBits( ( image[column] ) ) );
		}
		glcdSetPageColumn( ( x / 8 ) - ( page ) , y );
	}
}

void glcdSetFont					(const uint8_t __flash *chooseFontPtr)												
{	
	font.fontPtr = chooseFontPtr;
}

void glcdPutc						( char c , uint8_t y , uint8_t x )													
{	
	uint16_t	index = 0;	
	uint8_t		page = 0;
	uint8_t		yPos = y;
	uint8_t		xPos = x;
	
	
	if ( yPos >= GLCD_HEIGHT )
	{
		yPos = GLCD_HEIGHT - 1;
	}
	
	if ( xPos >= GLCD_WIDTH )
	{
		xPos = GLCD_WIDTH - 1;
	}
	
	font = calcFontStart( c, font , font.fontPtr );	
	
	#define FONT_IS_FIXED			0x01
	#define FONT_IS_NOT_FIXED		(!(FONT_IS_FIXED))

	/*
	*	Ist wichtig für den Abstand der Zeichen!
	*/
	if ( font.fontPtr[FONT_FONT_FIXED] == FONT_IS_FIXED )
	{
		font.width = font.fontPtr[FONT_CHAR_WIDTH];
	}
	
	page = font.fontPtr[FONT_CHAR_HIGH] % 8;
	if ( page == 0 )
	{
		page = 1;
	}
	
	glcdSetPageColumn( ( y / 8 ) , x );
	
	for ( uint8_t i = 0 ; i < page + 1 ; i++ ) // Berechne die Anzahl der benötigten Reihen
	{	
		/*
		*	Bei Fonts die höher als 8 Pixel sind, müssen die letzten Zeilen dementprechend behandelt werden.
		*	Es entsteht eine Lücke, weil das Font nicht kompatibel zu einem senkrecht zeichnenden Display ist
		*/
		if ( ( x == ( ( ( font.fontPtr[FONT_CHAR_HIGH] / 8 ) + 2 ) - 1 ) ) && font.fontPtr[FONT_CHAR_HIGH] > 8 )
		{
			for ( ; index < ( font.width * i ) ; index++ )
			{
				glcdSendData( swapBits ( font.fontPtr[ font.indexNum + index ] ) << ( ( i * 8 ) - font.fontPtr[FONT_CHAR_HIGH] ) );
			}
			break;
		}
		
 		for ( ; index < ( font.width * i ) ; index++ )
 		{	
 			glcdSendData( font.fontPtr[ font.indexNum + index ] );
		}
		glcdSetPageColumn( ( y / 8 ) - i , x );
	}
}

void glcdPuts						( char *str , uint8_t y , uint8_t x )												
{
	uint8_t yPos = y;
	uint8_t xPos = x;
	
	if ( yPos >= GLCD_HEIGHT )
	{
		yPos = GLCD_HEIGHT - 1;
	}
	
	if ( xPos >= GLCD_WIDTH )
	{
		xPos = GLCD_WIDTH - 1;
	}
	
	uint16_t space = 0;
	do 
	{
		glcdPutc( *str , yPos , space + x );
		space += ( font.width ) + 1; // nächste Schreibposition anhand der größe vom Zeichen summieren.		
	} while ( *str++ );
}

void glcdDrawRect					( uint8_t y , uint8_t x , uint8_t h , uint8_t w , uint8_t *buff )					
{
	glcdSendBuffer( buff );
}

void glcdDrawLine					( uint8_t y , uint8_t x , uint8_t leng )											
{ 
	glcdSetPageColumn( 7 - y , x );
	for ( uint8_t c = 0 ; c < leng ; c++ )
	{
		//glcdSetPixel( y , c );
	}
}

void glcdClearLine					( uint8_t y , uint8_t x , uint8_t leng )											
{
	glcdSetPageColumn( 7 - y , x );
	for ( uint8_t c = 0 ; c < leng ; c++ )
	{
		//glcdClearPixel( y,c );
	}
}

