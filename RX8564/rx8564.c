/* Generated by CodeDescriptor 1.2.0.0713 */
/*
* Project Name      -> RX8564
* Version           -> 1.0.0.0714
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 14.07.2017 07:18:15
* Description       -> Device Driver
*
*
*
*/



#include <stdbool.h>
#include "../Includes/rx8564.h"



static uint8_t uiBuff[11] = "";


inline uint8_t			RtcBcdToDec				( uint8_t uiValue )					
{
	return ( ( ( uiValue & 0xF0 ) >> 4 ) * 10 ) + ( uiValue & 0x0F );
}

inline uint8_t			RtcDecToBcd				( uint8_t uiValue )					
{	
	return ( ( ( uiValue / 10 ) << 4 ) | ( uiValue % 10 ) );
}


static inline uint8_t	RtcRead					( uint8_t *pBuff , uint8_t uiLeng )	
{
	uint8_t x = 0;
	
	i2c_start( RX8564_ADDR + I2C_WRITE );
	i2c_write( pBuff[0] );// Register Adresse

	if ( i2c_rep_start( RX8564_ADDR + I2C_READ ) )
	{	
		i2c_stop();	
		return 1;
	}
	
	for ( x = 0 ; x < ( uiLeng - 1 ) ; x++ )
	{
		pBuff[x] = i2c_readAck();
	}
	pBuff[x+1] = i2c_readNak();
	
	i2c_stop();
	
	return 0;
}

static inline uint8_t	RtcWrite				( uint8_t *pBuff , uint8_t uiLeng )	
{
	i2c_start_wait( RX8564_ADDR + I2C_WRITE );

	for ( uint8_t i = 0 ; i < uiLeng ; i++ )
	{
		i2c_write( pBuff[i] );
	}
	
	i2c_stop();
	
	return 0;
}


void					RtcInit					( void )																	
{
	i2c_init();
	
	uiBuff[0] = eRTC_REG_CTRL1;
	uiBuff[1] = 0x00;
	RtcWrite( uiBuff , 2 );
}

void					RtcSetTime				( uint8_t uiHour , uint8_t uiMinute , uint8_t uiSecond )					
{
	uiBuff[0] = eRTC_REG_SEC;
	uiBuff[1] = RtcDecToBcd( uiSecond );
	uiBuff[2] = RtcDecToBcd( uiMinute );
	uiBuff[3] = RtcDecToBcd( uiHour );
	RtcWrite( uiBuff , 4 );
} 
   
void					RtcSetDate				( uint8_t uiDay , uint8_t uiWeekDay , uint8_t uiMonth , uint16_t uiYear )	
{
	uiBuff[0] = eRTC_REG_DAY;
	uiBuff[1] = RtcDecToBcd( uiDay );
	uiBuff[2] = RtcDecToBcd( uiWeekDay );
	uiBuff[3] = RtcDecToBcd( uiMonth );
	uiBuff[4] = RtcDecToBcd( uiYear - 2000 );
	RtcWrite( uiBuff , 5 );    
}
  
void					RtcSetAlert				( uint8_t uiDay , uint8_t uiWeekDay , uint8_t uiHour , uint8_t uiMinute )	
{
	uiBuff[0] = eRTC_REG_ALERT_MIN;
	uiBuff[1] = RtcDecToBcd( uiMinute );
	uiBuff[2] = RtcDecToBcd( uiHour );
	uiBuff[3] = RtcDecToBcd( uiDay );
	uiBuff[4] = RtcDecToBcd( uiWeekDay );
	RtcWrite( uiBuff , 5 );
 }
  
void					RtcSetClkOut			( uint8_t uiFreq )	
{    
	uiBuff[0] = eRTC_REG_CLKOUT;
	uiBuff[1] = uiFreq;
	RtcWrite( uiBuff , 2 );	
}
 
void					RtcGetData				( sRtc_t *psRtc )	
{   
	uiBuff[0] = eRTC_REG_SEC;
	RtcRead( uiBuff , sizeof( uiBuff ) );

	psRtc->sTime.uiSecond	=	RtcBcdToDec( uiBuff[0] & 0x7F );
	psRtc->sTime.uiMinute	=	RtcBcdToDec( uiBuff[1] & 0x7F );
	psRtc->sTime.uiHour		=	RtcBcdToDec( uiBuff[2] & 0x3F );	
	
	psRtc->sDate.uiDay		=	RtcBcdToDec( uiBuff[3] & 0x3F );
	psRtc->sDate.uiDayName	=	RtcBcdToDec( uiBuff[4] & 0x07 );
	psRtc->sDate.uiMonth	=	RtcBcdToDec( uiBuff[5] & 0x1F );
	psRtc->sDate.uiYear		=	RtcBcdToDec( uiBuff[6] );
	
	psRtc->sAlert.uiMinute	=	RtcBcdToDec( uiBuff[7] & 0x7F );
	psRtc->sAlert.uiHour	=	RtcBcdToDec( uiBuff[8] & 0x7F );
	psRtc->sAlert.uiDay		=	RtcBcdToDec( uiBuff[9] & 0x7F );
	psRtc->sAlert.uiDayName	=	RtcBcdToDec( uiBuff[10] & 0x7F);

}

void					RtcSetTimerCtrl2		( uint8_t uiMask )	
{
	uiBuff[0] = eRTC_REG_CTRL2;
	uiBuff[1] = uiMask;
	RtcWrite( uiBuff , 2 );
}
 
void					RtcSetTimerControl		( uint8_t uiMask )	
{
	uiBuff[0] = eRTC_REG_TIMER_CTRL;
	uiBuff[1] = uiMask;
	RtcWrite( uiBuff , 2 );
}

uint8_t					RtcReadTimer			( void )			
{	
	uiBuff[0] = eRTC_REG_TIMER;
	RtcRead( uiBuff , 1 );

	return uiBuff[0];
}


bool					RtcIsLearYear			( const uint16_t year )							
{
  // Die Regel lautet: Alles, was durch 4 teilbar ist, ist ein Schaltjahr.
  // Es sei denn, das Jahr ist durch 100 teilbar, dann ist es keins.
  // Aber wenn es durch 400 teilbar ist, ist es doch wieder eins.

	if (  (year % 400 ) == 0 )
	{
		return true;
	}
	else if (  ( year % 100 ) == 0 )
	{
		return false;
	}
	else if (  ( year % 4 )  == 0)
	{
		return true;	
	}
    
  return false;
}                   

uint16_t				RtcGetNumOfDays			( const uint8_t month , const uint16_t year )	
{
  //                     ungueltig,Jan,Feb,Mrz,Apr,Mai,Jun,Jul,Aug,Sep,Okt,Nov,Dez
  uint8_t daysPerMonth[] = {  0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

  if ( month == 2 )
  {
    // Februar: Schaltjahr unterscheiden
    if ( RtcIsLearYear( year ) )
    {
    	return 29;
	}
    else
    {
    	return 28;
	} 
  }

  if ( ( month >= 1 ) && ( month <= 12 ) )
  {
  	return daysPerMonth[month];
  }
  else
  {
    return 0;
  }
  
}                   

uint16_t				RtcGetDays				( const uint16_t year )							
{
  return ( RtcIsLearYear( year ) ) ? 366 : 365;
}                   

uint16_t				RtcGetWeekDay			( const uint8_t day , const uint8_t month , const uint16_t year )	
{
	//                       ungueltig Jan Feb Mrz Apr Mai Jun Jul Aug Sep Okt Nov Dez 
	uint8_t monthOffset[13] = {  0 ,  0 ,  3 ,  3 ,  6 ,  1 ,  4 ,  6 ,  2 ,  5 ,  0 ,  3 ,  5 };
	uint16_t result = 0;
	
	
	// Monat / Tag - Plausi pruefen:
	if ( ( day > 31 ) || ( month > 12 ) || ( month <= 0 ) || ( day <= 0 ) || ( year <= 0 ) )
	{
		return -1;
	}
	
	uint8_t dayDigit 		= ( day % 7 );
	uint8_t monthDigit 		= monthOffset[month];
	uint8_t yearDigit 		= ( ( year % 100 ) + ( ( year % 100 ) / 4 ) ) % 7;
	uint8_t centuryDigit 	= ( 3 - ( ( year / 100 ) % 4 ) ) * 2;
	
	// Schaltjahreskorrektur:
	if ( ( month <= 2 ) && ( RtcIsLearYear( year ) ) )
	{
		dayDigit = dayDigit + 6;
	}
	
	result = ( dayDigit + monthDigit + yearDigit + centuryDigit ) % 7;
	
	// Ergebnis:
	// 0 = Sonntag
	// 1 = Montag
	// 2 = Dienstag
	// 3 = Mittwoch
	// 4 = Donnerstag
	// 5 = Freitag
	// 6 = Samstag
	return result;
}   

uint16_t				RtcGetDayOfYear			( const uint8_t day , const uint8_t month , const uint16_t year )	
{
  // Der wievielte Tag des Jahres ist dieser Tag
  if ( ( month == 0 ) || ( month > 12 ) )
  {
    return -1;
  }

  uint16_t localDay 		= day;
  uint8_t localMonth 	= month;

  while ( localMonth > 1 )
  {
    localMonth--;
    localDay += RtcGetNumOfDays( localMonth , year );
  }

  return localDay;
}                   

uint16_t				RtcGetWeek				( uint16_t day , uint16_t month , uint16_t year )					
{
  // Berechnung erfolgt analog DIN 1355, welche besagt:
  // Der erste Donnerstag im neuen Jahr liegt immer in der KW 1.
  // "Woche" ist dabei definiert als [Mo, ..., So].

  uint16_t dayOfYear = RtcGetDayOfYear( day , month , year );

  // Berechnen des Wochentags des 1. Januar:
  uint16_t weekDay1Jan = RtcGetWeekDay( 1 , 1 , year );

  // Sonderfaelle Freitag und Samstag
  if (weekDay1Jan >= 5) 
  {
  	weekDay1Jan = weekDay1Jan - 7;
  }
    
  // Sonderfaelle "Jahresanfang mit KW - Nummer aus dem Vorjahr"
  if ( ( dayOfYear + weekDay1Jan ) <= 1 )
  {
    return RtcGetWeek( 31 , 12 , year - 1 );
  }

  uint16_t week = ( ( dayOfYear + weekDay1Jan + 5 ) / 7 );

  // 53 Kalenderwochen hat grunds?tzlich nur ein Jahr, 
  // welches mit einem Donnerstag anf?ngt !
  // In Schaltjahren ist es auch mit einem Mittwoch moeglich, z.B. 1992
  // Andernfalls ist diese KW schon die KW1 des Folgejahres.
  if ( week == 53 )
  {
    bool leapYear = RtcIsLearYear( year );

    if ( ( weekDay1Jan  ==  4 ) ||  ( weekDay1Jan  == -3 ) ||  ( ( weekDay1Jan ==  3 ) && leapYear ) || ( ( weekDay1Jan == -4 ) && leapYear ) )
    {
    	// Das ist korrekt und erlaubt
    }
    else
    {
    	week = 1; // Korrektur des Wertes
	}
      
  }

  return week;
}      
