/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> WSQ 3000
* Version           -> 1.0.0.0813
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 13.08.2018 10:10:01
* Description       -> Timer
*
*	Wichtig! Sollte irgendein Interrupt aktiviert sein,
*	muss unbedingt der dazugehörige Vektor im Quellkode vorhanden sein. 
*
*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdlib.h>



void		timerOVFInit			( TC0_t *tim0 , TC1_t *tim1 )	
{
	if ( tim0 )
	{
		tim0->CTRLA		= TIMER_PRESCALER_gc;	// Takt konfigurieren ( mit ggf. Vorteiler )
		tim0->PER		= TIMER_CALC;			// Interupt Überlauf berechnen
		tim0->INTCTRLA	= TC_OVFINTLVL_HI_gc;	// Interrupt "Overflow" aktivieren / Priorität des Interrupts festlegen
	}
	else if ( tim1 )
	{
		tim1->CTRLA		= TIMER_PRESCALER_gc;	// Takt konfigurieren ( mit ggf. Vorteiler )
		tim1->PER		= TIMER_CALC;			// Interupt Überlauf berechnen
		tim1->INTCTRLA	= TC_OVFINTLVL_HI_gc;	// Interrupt "Overflow" aktivieren / Priorität des Interrupts festlegen		
	}
	
	PR.PRPC = 0x00;														// Power einschalten
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;  // Interrupts freigeben ( sei() muss trodzdem sein! )	

	sei();
}

void		timerCMPInit			( TC0_t *tim0 , enum tc0_ccx_enum channel0 , TC1_t *tim1 , enum tc1_ccx_enum channel1 )										
{		
	/*
	*	Hier wird ohne Hardware Pin Toggeln gearbeitet. Sollte von 
	*	außen der entsprechende Hardware Pin getoggelt werden, muss
	*	in das CTRLB Register ( ATXMEGA256A3BU ) noch TCx_CCxEN_bm gesetzt werden.
	*/
	if ( tim0 )
	{
		tim0->CTRLA						= TIMER_PRESCALER_gc;	// Takt konfigurieren ( mit ggf. Vorteiler )
		tim0->CTRLB						= TC_WGMODE_FRQ_gc;		// Compare Match 'A' aktivieren	
		tim0->INTCTRLB					= TC_CCAINTLVL_HI_gc;	// Interrupt "Compare Match" aktivieren / Priorität des Interrupts festlegen	
		TIMER_CCx( tim0 , channel0 )	= TIMER_CALC;			// Compare Match Wert
	}
	else if ( tim1 )
	{
		tim1->CTRLA						= TIMER_PRESCALER_gc;	// Takt konfigurieren ( mit ggf. Vorteiler )
		tim1->CTRLB						= TC_WGMODE_FRQ_gc;		// Compare Match 'A' aktivieren
		tim1->INTCTRLB					= TC_CCAINTLVL_HI_gc;	// Interrupt "Compare Match" aktivieren / Priorität des Interrupts festlegen		
		TIMER_CCx( tim1 , channel1 )	= TIMER_CALC;			// Compare Match Wert
	}

	PR.PRPC	= 0x00;													    // Power einschalten
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;	// Interrupts freigeben ( sei() muss trodzdem sein! )
	
	sei();
}

void		timerPWMInit			( TC0_t *tim0 , enum tc0_ccx_enum channel0 , TC1_t *tim1 , enum tc1_ccx_enum channel1 , uint16_t period , uint16_t compare )	
{
	if ( tim0 )
	{
		tim0->CTRLA						= TC_CLKSEL_DIV1_gc;											// Takt konfigurieren ( mit ggf. Vorteiler )
		tim0->CTRLB						= ( TC_WGMODE_SINGLESLOPE_gc | ( TC0_CCAEN_bm << channel0  ) );	// Compare Match 'A' aktivieren	
		tim0->PER						= period;														// Maximaler Zählerwert von TIMERx														// Compare Match Wert		
		TIMER_CCx( tim0 , channel0 )	= compare;
	}
	else if ( tim1 )
	{
		tim1->CTRLA						= TC_CLKSEL_DIV1_gc;											// Takt konfigurieren ( mit ggf. Vorteiler )
		tim1->CTRLB						= ( TC_WGMODE_SINGLESLOPE_gc | ( TC1_CCAEN_bm << channel1  ) );	// Compare Match 'A' aktivieren
		tim1->PER						= period;														// Maximaler Zählerwert von TIMERx		
		TIMER_CCx( tim1 , channel1 )	= compare;
	}

	sei();	
}

uint8_t		timerSetCompareValue	( TC0_t *tim0 , TC1_t *tim1 , uint8_t ccx , uint16_t val )	
{
	if ( ccx > 3 ) return 1; // Register nicht vorhanden..
	
	if ( tim0 )
	{
		TIMER_CCx( tim0 , ccx ) = val;
	}
	else if ( tim1 )
	{
		TIMER_CCx( tim1 , ccx ) = val;
	}
	
	return 0;
}

void		timerStart				( TC0_t *tim0 , TC1_t *tim1 )	
{
	if ( tim0 )
	{
		tim0->CTRLA = TIMER_PRESCALER_gc;
	}
	else if ( tim1 )
	{
		tim1->CTRLA = TIMER_PRESCALER_gc;
	}
}

void		timerStop				( TC0_t *tim0 , TC1_t *tim1 )	
{
	if ( tim0 )
	{
		tim0->CTRLA = 0;
	}
	else if ( tim1 )
	{
		tim1->CTRLA = 0;
	}	
}




