/* Generated by CodeDescriptor 1.5.0.0907 */
/*
* Project Name      -> WSQ 3000
* Version           -> 1.0.0.0813
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 13.08.2018 10:10:01
* Description       -> Timer
*
*	Wichtig! Sollte irgendein Interrupt aktiviert sein,
*	muss unbedingt der dazugehörige Vektor im Quellkode vorhanden sein. 
*
*/

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdlib.h>

#include "../Headers/xmega_timer.h"




void timer0OVFInit			( TC0_t *tim )					
{
	tim->CTRLA		= TIMER_PRESCALER_gc;								// Takt konfigurieren ( mit ggf. Vorteiler )
	tim->PER		= TIMER_CALC;										// Interupt Überlauf berechnen
	tim->INTCTRLA	= TC_OVFINTLVL_HI_gc;								// Interrupt "Overflow" aktivieren / Priorität des Interrupts festlegen
	
	PR.PRPC = 0x00;														// Power einschalten
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;  // Interrupts freigeben ( sei() muss trodzdem sein! )	
}

void timer0CMPInit			( TC0_t *tim )					
{		
	/*
	*	Hier wird ohne Hardware Pin Toggeln gearbeitet. Sollte von 
	*	außen der entsprechende Hardware Pin getoggelt werden, muss
	*	in das CTRLB Register ( ATXMEGA256A3BU ) noch TCx_CCxEN_bm gesetzt werden.
	*/
	tim->CTRLA		= TIMER_PRESCALER_gc;								// Takt konfigurieren ( mit ggf. Vorteiler )
	tim->CTRLB		= TC0_WGMODE0_bm ;									// Compare Match 'A' aktivieren	
	tim->CCA		= TIMER_CALC;										// Compare Match Wert
    tim->INTCTRLB	= TC_CCAINTLVL_HI_gc;								// Interrupt "Compare Match" aktivieren / Priorität des Interrupts festlegen
	
	PR.PRPC = 0x00;														// Power einschalten
	PMIC.CTRL |= PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;	// Interrupts freigeben ( sei() muss trodzdem sein! )
}

uint8_t timerSetCompareValue	( TC0_t *tim0 , TC1_t *tim1 , uint8_t ccx , uint16_t val )	
{
	if ( ccx > 4 )
	{
		return 1; // Register nicht vorhanden..
	}
	
	if ( tim0 != NULL )
	{
		(&(tim0->CCA))[ccx] = val;
	}else if ( tim1 != NULL )
	{
		(&(tim1->CCA))[ccx] = val;
	}
	return 0;
}

void timerStart				( TC0_t *tim0 , TC1_t *tim1 )	
{
	if ( tim0 != NULL )
	{
		tim0->CTRLA = TIMER_PRESCALER_gc;
	}else if ( tim1 != NULL )
	{
		tim1->CTRLA = TIMER_PRESCALER_gc;
	}
}

void timerStop				( TC0_t *tim0 , TC1_t *tim1 )	
{
	if ( tim0 != NULL )
	{
		tim0->CTRLA = 0;
	}else if ( tim1 != NULL )
	{
		tim1->CTRLA = 0;
	}	
}




