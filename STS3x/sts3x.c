/* Generated by CodeDescriptor 1.3.0.0714 */
/*
* Project Name      -> STS3x
* Version           -> 1.0.0.0810
* Author            -> Hm @ Workstadion.: QP-01-02
* Build Date        -> 10.08.2017 06:51:39
* Description       -> Description
*
*
*
*/

#include <avr/io.h>
#include <avr/crc16.h>
#include "sts3x.h"
#include "i2cmaster.h"

sts3x_t sts3x;

void sts3x_init(void)
{
	i2c_start_wait( STS3x_ADDR + I2C_WRITE );
	
	i2c_write( STS3x_1_MPS_MSB );
	i2c_write( STS3x_1_MPS_HIG_LSB );
 	i2c_write( STS3x_FETCH_DATA_MSB );
 	i2c_write( STS3x_FETCH_DATA_LSB );	

	i2c_stop();
	
}

int16_t sts3x_calc(uint16_t temp)
{
	double stemp=temp;
	stemp *= 175;
	stemp /= 0xffff;
	stemp = -45 + stemp;
	
	return (int16_t)stemp;
}

uint16_t sts3x_read(void)
{
	#define MSB	0
	#define LSB 1
	#define CRC	2
	
	uint8_t read[3] = { 0 , 0 , 0 };
	
	i2c_start_wait( STS3x_ADDR + I2C_READ );
	read[MSB] = i2c_readAck();
	read[LSB] = i2c_readAck();
	read[CRC] = i2c_readNak();
	i2c_stop();

	uint8_t crc = 0xff;
	crc = _crc8_ccitt_update(crc,read[MSB]);
	crc = _crc8_ccitt_update(crc,read[LSB]);

	/* 
	* Generierten CRC mit empfangenen überprüfen 
	*/
	if ( crc == read[CRC] )
	{
		return (uint16_t)read[MSB] << 8 | read[LSB];
	}
	
	/*
	*	Schlägt eine Messung fehl oder CRC passt nicht
	*	wird der Wert für "0 °C" zurück gegeben
	*/
	return 17000;
}

int16_t sts3x_get_temp(void)
{
	return sts3x_calc( sts3x_read() );
}